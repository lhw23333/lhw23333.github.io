[TOC] 

#### 继承和多态 动态绑定
- [继承]可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。可以扩展已存在的代码模块。  
- [多态]是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。父类引用指向子类对象。
- [封装]成员函数的解析再编译时静态进行，virtual虚函数在动态时进行
  
###### 继承

1. public、protected、private指定继承方式。基类成员在派生类中的访问权限不得高于继承方式中指定的权限。可通过using更改基类成员的访问权限。
2. 派生类遮盖基类同名成员，且基类和派生类的同名函数不构成重载
3. 继承时的作用域嵌套，派生类的作用域嵌套在基类作用域中：如果不能在派生类作用域中确定名字，就在外围基类作用域中查找该名字的定义。  
基类指针只能访问基类成员，不管指向的是派生类还是基类。这是因为函数名查找是在静态编译时进行，且不是虚函数不会产生多态行为。  
理解 C++中继承层次的关键在于理解如何确定函数调用。确定函数调用遵循以下四个步骤：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）首先确定进行函数调用的对象、引用或指针的静态类型

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）在该类中查找函数，如果找不到，就在直接基类中查找，如此循着类的继承链往上找，直到找到该函数或者查找完最后一个类。如果不能在类或其相关基类中找到该名字，则调用是错误的。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）一旦找到了该名字,就进行常规类型检查,查看如果给定找到的定义,该函数调用是否合法。  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）假定函数调用合法,编译器就生成代码。如果函数是虚函数且通过引用或指针调用,则编译器生成代码以确定根据对象的动态类型运行哪个函数版本,否则,编译器生成代码直接调用函数。  


###### 多继承

- 单一的一般继承  
 虚函数表在最前面的位置。  
 成员变量根据其继承和声明顺序依次放在后面。  
 在单一的继承中，被overwrite的虚函数在虚函数表中得到了更新。
- 多重继承  
每个父类都有自己的虚表。  
子类的成员函数被放到了第一个父类的表中。  
内存布局中，其父类布局依次按声明顺序排列。  
每个父类的虚表中的f()函数都被overwrite成了子类的f()。这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。  
![image](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/EntryImages/20081015/dd03.jpg)![image](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/EntryImages/20081015/dd04.jpg)
- 重复继承    
最顶端的父类B其成员变量存在于B1和B2中，并被D给继承下去了。而在D中，其有B1和B2的实例，于是B的成员在D的实例中存在两份，一份是B1继承而来的，另一份是B2继承而来的。所以，如果我们使用以下语句，则会产生二义性编译错误：重复的基类数据成员可能并不是我们想要的。所以，C++引入了虚基类的概念。

```
D d;
d.id = 0; //二义性错误
d.B1::id = 1;//正确
d.b2::id = 2;//正确
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![image](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/EntryImages/20081015/dd05.jpg)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![image](https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/EntryImages/20081015/dd06.jpg)  

- 钻石型多重虚拟继承。。。虚拟继承的出现就是为了解决重复继承中多个间接父类的问题的。上述的“重复继承”只需要把B1和B2继承B的语法中加上virtual 关键，就成了虚拟继承， 少了重合的部分。但是，代价是增加了一个虚函数指针 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![image](https://img-blog.csdnimg.cn/20201025164526288.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIzNTk3NQ==,size_16,color_FFFFFF,t_70#pic_center)
![image](https://img-blog.csdnimg.cn/20201025164733623.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDIzNTk3NQ==,size_16,color_FFFFFF,t_70#pic_center)


1。虚拟继承时，派生类需要调用间接基类的构造函数，来进行初始化，因为通过直接基类调用时会发生参数错误，所以直接通过派生类来进行超类的初始化   
2。多继承下的构造函数，基类构造函数的调用顺序和和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同。多继承形式下析构函数的执行顺序和构造函数的执行顺序相反。  
3。 当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，编译器不知道使用哪个基类的成员。这个时候需要在成员名字前面加上类名和域解析符::，以显式地指明到底使用哪个类的成员，消除二义性。  
4。多继承时，派生类中会有多个虚指针，每个父类都有自己的虚表。子类的成员函数被放到了第一个父类的表中。


###### 虚函数 https://blog.twofei.com/496/   
==纯虚函数对该类没有实际意义，纯虚函数会被赋值为0==  
==基类指针指向派生类对象的情况下，无法内联优化==   
==虚函数的默认参数问题，，基类中虚函数的默认参数会在编译过程就被保存，再调用子类的函数后发生多态，编译器会使用基类的默认参数，这是因为是实参值由静态类型决定，而此时的静态类型是父类的指针或引用。==

虚函数有两大作用：  
（1）定义子类对象，并调用对象中未被子类覆盖的基类函数A。同时在该函数A中，又调用了已被子类覆盖的基类函数B。那此时将会调用基类中的函数B，可我们本应该调用的是子类中的覆盖函数B。虚函数即能解决这个问题。  
（2）在使用指向子类对象的基类指针，并调用子类中的覆盖函数时，如果该函数不是虚函数，那么将调用基类中的该函数；如果该函数是虚函数，则会调用子类中的该函数。

有两种情况虚函数机制不会触发  
1. 基类的constructo和destructor内（因为如果调用派生类的虚函数可能访问到未经初始化的data menber）
2. 当我们使用基类对象而不是基类pointer和reference时
虚函数是实现多态（动态绑定）的基础，通过向api传入指向子类的指针使用我们自己定义的子类函数，覆盖api中的基类函数

虚函数的原理  
本质是一个与函数表，通过该类创建的对象实例，会在内存空间的前4字节保存一个指向虚函数表的指针==v_fptr==。  
==_vfptr==指向的虚函数表，是类独有的，而且被该类的所有对象共享。  
虚函数表的实质，是一个虚函数地址的数组，它包含了类中每个虚函数的地址，既有当前类定义的虚函数，也有覆盖父类的虚函数，也有继承而来的虚函数。

当子类覆盖了父类的虚函数时，子类虚函数表将包含子类虚函数的地址，而不会有父类虚函数的地址。

同时，当用基类指针指向子类对象时，基类指针指向的内存空间中的__vfptr依旧指向了子类的虚函数表。所以，基类指针依旧会调用子类的虚函数。
    

RTTI机制 typeid运算符  
typeid 运算符用来获取表达式的类型信息 
- 对于基本类型（int、float 等C++内置类型）的数据，类型信息所包含的内容比较简单，主要是指数据的类型。 
- 对于类类型的数据（也就是对象），类型信息是指对象所属的类、所包含的成员、所在的继承关系等。
- 类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。  
  

typeid 会把获取到的类型信息保存到一个 type_info 类型的对象里面，并返回该对象的常引用；当需要具体的类型信息时，可以通过成员函数来提取  
type_info 类的几个成员函数 
- name() 用来返回类型的名称。
- raw_name() 用来返回名字编码（Name Mangling）算法产生的新名称。
- hash_code() 用来返回当前类型对应的 hash 值。hash 值是一个可以用来标志当前类型的整数，有点类似学生的学号、公民的身份证号、银行卡号等。不过 hash 值有赖于编译器的实现，在不同的编译器下可能会有不同的整数，但它们都能唯一地标识某个类型。  
- bool operator== (const type_info& rhs) const;
重载运算符“==”，判断两个类型是否相同，rhs 参数是一个 type_info 对象的引用。
- bool operator!= (const type_info& rhs) const;
重载运算符“!=”，判断两个类型是否不同，rhs 参数是一个 type_info 对象的引用。  
  

为了减小编译后文件的体积，编译器不会为所有的类型创建 type_info 对象，只会为使用了 typeid 运算符的类型创建。不过有一种特殊情况，就是带虚函数的类（包括继承来的），不管有没有使用 typeid 运算符，编译器都会为带虚函数的类创建 type_info 对象，且type_info的构造函数是private的，所以不能在代码中实例化，只能由编译器在内部实例化（借助友元）。而且重载了“ = ”运算符，也是private，所以也不能赋值   
==多态类的对象的类型信息保存再虚函数表的索引-1的项中，该项是一个type_info的地址，该对象保存着对应的类型信息，每个类都对应一个唯一的type_info对象==  
![image](https://img-blog.csdn.net/20150614030601225?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

RTTI机制可以在运行时类型识别，程序能够使用基类的指针或引用来检查所指对象的实际派生类，这样就解决了多态指针识别其指向对象的问题，  
提供了typeid操作符，返回指针和引用所指的实际类型；  
dynamic_cast操作符，将基类类型的指针或引用安全地转换为其派生类类型的指针或引用。   

dynamic_cast强制转换运算符   
普通函数通过函数名在该类型的作用域中查找调用，而虚函数通过虚指针，充当一个中间工具，不直接在作用域中查找，而是在虚函数表中进行查找，将函数从代码区分离了出来，由此实现类虚函数查找的特殊性。
- dynamic_cast转换符只能用于含有虚函数的类
- 如果指向派生类的基类指针B想访问派生类D中的除虚函数之外的成员时就需要把该指针转换为指向派生类D的指针，以达到访问派生类D中特有的成员的目的
- dynamic_cast<D*>(pb)->g()这样可以访问派生类的非虚函数g()，但不会影响pb的指针类型
- dynamic_cast转换符只能用于指针或者引用
- 如果转换失败，如果是指针则反回一个0值，如果是转换的是引用，则抛出一个bad_cast异常，所以在使用dynamic_cast转换之间应使用if语句对其转换成功与否进行测试  
- 
```
if(dynamic_cast<D*>(pb)){}
else{}

```


​    
###### 抽象基类设计  
1. 定义基类共有接口
2. 设法找出哪些操作与类型相关，也就是哪些行为必须根据不同的派生类有不同的实现方法，并将其设为virtual
3. 如果基类定义有一个或多个虚函数，应该要将其析构定义为virtual，如果删除该指针delete []p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。  
4. 析构函数不定义为虚函数时：编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。
5. 派生类的初始化过程 创建子类的调用顺序  
![image](https://img-blog.csdnimg.cn/20181121160813923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDc1MjM0,size_16,color_FFFFFF,t_70)
--父类的静态代码块--

--子类的静态代码块--

--子类主程序--

--父类的非静态代码块--

--父类的有参构造函数--父亲的名字

--父类的方法--

--父类的非静态代码块--

--父类的无参构造函数--

--子类的非静态代码块--

--子类的有参构造函数--儿子的名字

--子类Override了父类的方法--

6.抽象基类和接口的区别  
- 抽象类继承，接口要被实现
- 接口只能做方法声明，抽象类可以可声明可实现
- 接口定义的变量只能是公共的静态变量，抽象类为普通变量  
接口是设计（动作抽象），抽象类是重构（根源抽象）
- 接口抽象层次更高
- 抽象类可以有具体方法和属性，接口只能有抽象方法和不可变常量
7.抽象类不能被实例化，但是我们还是要对其成员变量进行初始化，如果我们在派生类中对基类成员初始化，这不符合OOP的设计准则，所以我们可以将基类的constructor设为protected，这样就避免了抽象类的实例化，我们可以通过初始化列表对基类初始化  


```
void Fibonacci(int len, int beg_pos)
	:num_sequence(len, beg_pos, _elems)
```


#### 内链接性和外链接性
##### 内链接性
如果一个名称对于他的编译单元是局部的，并且在链接时不会与其他的编译单元中同样的名字冲突，那么这个名称就拥有内部链接。  
那么哪些实体拥有内部链接？  
1.  静态（static）全局变量，自由函数，友元函数定义
2.  类的定义
3.  类的定义
4.  Union共用体定义
5.  名字空间的const常量定义
6.  枚举类型定义
7.  所有的声明（有人将声明归结为无链接）    

##### 外链接性
一个多文件的程序中，一个实体可以在链接时与其他编译单元交互，那么这个实体就拥有外部链接。  
那么哪些实体拥有外部链接？
1. 类的非内联函数（包括成员函数和静态类成员函数）的定义
2. 类的静态成员变量的定义
3. 名字空间或全局的非静态的自由函数，非静态变量，非友元函数的定义  

##### 内外链接的简单理解和设计原因
有一些名字定义所表示的实体拥有外部链接，这样就意味着他可以跨越编译单元去进行代码的链接。所以，拥有外部链接的实体如果被声明在头文件并且被多个.cpp文件包含,可能就会出现链接冲突错误，因为每个包含这个拥有外部链接实体的.cpp都会分配空间，当多个编译单元链接的时候，连接器就会面对多个相同的名字，无法正常链接到正确的对象。  
**此时就需要使用内部链接避免冲突**  
简单理解，向类，枚举，结构体这种，对结构进行定义，并没有实例化的，是有内链接性，每次链接都会在内存中重新拷贝一份，我们想获得的是他的类型信息去进行实例  
而其他的如非静态变量，在定义的时候就分配了内存去保存一个数据，而在链接的时候我们想要的是他的数据，而不是他的类型信息，所以我们需要用外链接性去查找我们同一个内存，去访问同一个数据。而类的非内联函数，我们也是为了避免内存占用，采用外链接的形式去进行调用。

#### lib和dll（静态链接库和动态链接库）
静态库和动态库的概念我们已经了解清楚，此处我们仔细了解lib库和dll库的区别  
将一部分源文件预先编译成库文件，也即lib文件，当要使用其中的函数时，只需要链接lib文件就可以了，而不用再理会最初的源文件。  使用lib的方式有两种：
1. 在工程选项-〉link-〉Object/Library Module中加入hello.lib 
2. 可以在源代码中加入一行指令 
#pragma comment(lib, "hello.lib") 
- 静态lib：包含函数的代码本身（包括函数的索引，也包括实现），链接时拷贝加入程序之中。
- 动态lib：包含了函数所在的DLL文件和文件中函数位置的信息，函数实现代码由运行的时候加载在进程空间中DLL提供

#### 静态变量  
静态成员的提出是为了解决数据共享的问题。设置全局性的变量或对象是一种方法，但是有一定的局限性。  
###### 静态全局变量  
- 该变量在全局数据区分配内存
- 初始化：如果不显式初始化，那么将被隐式初始化为0（自动变量是随机的，除非是显式初始化）
- 该变量只在本源文件可见，严格地讲，应该从定义之处开始到本文件结束。==文件作用域下声明的const的常量默认为static存储类型。。静态全局的好处，在其他文件中可以定义相同名字的变量，而不会发生冲突。==
###### static局部变量  
函数体内的static变量  
###### 静态函数  
只在当前源文件中有效


###### static data member
静态数据成员，可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，保证了安全性，因此静态成员是类的所有对象中共享的成员，而不是某个对象的成员，使用静态数据成员可以节省内存，因为他是共有的，值可以更新  

静态数据成员存储在全局数据区。定义时要分配空间，所以不能在类声明中定义，应该在类外定义。  
 <数据类型><类名>::<静态数据成员> = <值>  
 ###### statci member function
 为类的全部服务，而不是为某一个类的具体对象服务，静态成员函数与静态数据成员一样，都是在类的内部实现，无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其余的静态成员函数  
-  出现在类体外的函数不能指定关键字static；
-  静态成员之间可以互相访问，包括静态成员函数访问静态数据成员和访问静态成员函数；
-  非静态成员函数可以任意地访问静态成员函数和静态数据成员；
-  静态成员函数不能访问非静态成员函数和非静态数据成员；
-  由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比，速度上会有少许的增长；
-  调用静态成员函数，可以用成员访问操作符(.)和(->)为一个类的对象或指向类对象的指调用静态成员函数。  


#### 智能指针  
###### shared_ptr智能指针  
-  unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。
-  创建方式  

```
std::shared_ptr<int> p1;             //不传入任何实参
std::shared_ptr<int> p2(nullptr);    //传入空指针 nullptr
std::shared_ptr<int> p3(new int(10));//明确指向
std::shared_ptr<int> p3 = std::make_shared<int>(10);//通过make_shared初始化
//调用拷贝构造函数
std::shared_ptr<int> p4(p3);//或者 std::shared_ptr<int> p4 = p3;
//调用移动构造函数
std::shared_ptr<int> p5(std::move(p4)); //或者 std::shared_ptr<int> p5 = std::move(p4);  
//会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针。
```
注意，同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常
- 在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。比如，对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。  
释放规则可以使用 C++11 标准中提供的 default_delete<T> 模板类，我们也可以自定义释放规则：也可以借助lambda表达式
```
//指定 default_delete 作为释放规则
std::shared_ptr<int> p6(new int[10], std::default_delete<int[]>());
//自定义释放规则
void deleteInt(int*p) {
    delete []p;
}
//初始化智能指针，并自定义释放规则
std::shared_ptr<int> p7(new int[10], deleteInt);
```


######  unique_ptr智能指针  
unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。 
- 基于 unique_ptr 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 unique_ptr 模板类没有提供拷贝构造函数，只提供了移动构造函数。
- 
```
std::unique_ptr<int> p4(new int);
std::unique_ptr<int> p5(p4);//错误，堆内存不共享
std::unique_ptr<int> p5(std::move(p4));//正确，调用移动构造函数
```
- 默认情况下，unique_ptr 指针采用 std::default_delete<T> 方法释放堆内存。当然，我们也可以自定义符合实际场景的释放规则。值得一提的是，和 shared_ptr 指针不同，为 unique_ptr 自定义释放规则，只能采用函数对象的方式。例如：

```
//自定义的释放规则
struct myDel
{
    void operator()(int *p) {
        delete p;
    }
};
std::unique_ptr<int, myDel> p6(new int);
//std::unique_ptr<int, myDel> p6(new int, myDel());
```

###### weak_ptr智能指针
C++11标准虽然将 weak_ptr 定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和 shared_ptr 类型指针搭配使用。甚至于，我们可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。

- weak_ptr<T> 模板类中没有重载 * 和 -> 运算符，这也就意味着，weak_ptr 类型指针只能访问所指的堆内存，而无法修改它。
- weak_ptr 指针更常用于指向某一 shared_ptr 指针拥有的堆内存，因为在构建 weak_ptr 指针对象时，可以利用已有的 shared_ptr 指针为其初始化。
- wp3 指针和 sp 指针有相同的指针。再次强调，weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少。

```
std::shared_ptr<int> sp (new int);
std::weak_ptr<int> wp3 (sp);
```

```
#include <iostream>
#include <memory>
using namespace std;
int main()
{
    std::shared_ptr<int> sp1(new int(10));
    std::shared_ptr<int> sp2(sp1);
    std::weak_ptr<int> wp(sp2);
    //输出和 wp 同指向的 shared_ptr 类型指针的数量
    cout << wp.use_count() << endl;
    //释放 sp2
    sp2.reset();
    cout << wp.use_count() << endl;
    //借助 lock() 函数，返回一个和 wp 同指向的 shared_ptr 类型指针，获取其存储的数据
    cout << *(wp.lock()) << endl;
    return 0;
}
```



#### template（泛型）编程  
###### 函数模板 
- 函数模板的实现机制  
编译器并不是把函数模板处理成能够处理任意类的函数  
编译器从函数模板通过具体类型产生不同的函数  
编译器会对函数模板进行两次编译：  
在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。  

###### 类模板
- 优点  
 (1)可用来创建动态增长和减小的数据结构    
（2）它是类型无关的，因此具有很高的可复用性。   
（3）它在编译时而不是运行时检查数据类型，保证了类型安全  
（4）它是平台无关的，可移植性   
（5）可用于基本数据类型
###### 偏特化与全特化
- 所有的模板类型T都明确化，并且写了一个类名与主模板类名相同的类，那么这个类就叫做全特化类。C++模板全特化之后已经失去了Template的属性了。
- 上面对主版本模板和全特化进行了定义，那么偏特化就是介于二者之间的模板，它的模板名与主版本模板名相同，但是它的模板型中，有被明确化的部分和没有被明确化的部分。
- 虚函数不能使用模板，因为二次编译会导致代码膨胀
- 模板调用顺序 全特化类>偏特化类>主版本模板类。这样的优先级顺序对性能也是最好的。
- 偏特化即模板参数没有全部确定，需要编译器在编译时进行确定。模板参数的类模板特化的几种类型①特化为绝对类型②特化为引用，指针类型③特化为另外一个类的模板。 
- 偏特化不是一种绝对的特化，只是对类型做了某些限定，但仍然保留了一定的模板性，比如对pointer和reference的特化可以不用进行全特化处理  




template即参数化的类型，这样可以将数据类型从class中剥离，可以让设计者专注于算法和类型的设计，使得同一操作的代码可以重用  
1. template  强类型的语言迫使我们未逻辑结构相同而具体数据类型不同的对象编写模式一致的代码，而c++模板的可以将数据类型抽离出来，使得我们可以更加方便的设计算法和类型  
2. 函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译，在声明处对模板代码本身进行编译（检查语法），在调用处对参数替换后的代码进行编译。  
3. 什么不可以将template的member funcation定义为virual  
编译器在编译一个类的时候，需要确定这个类的虚函数表的大小。一般来说，如果一个类有N个虚函数，它的虚函数表的大小就是N，如果按字节算的话那么就是4*N。  
如果允许一个成员模板函数为虚函数的话，因为我们可以为该成员模板函数实例化出很多不同的版本，也就是可以实例化出很多不同版本的虚函数，那么编译器为了确定类的虚函数表的大小，就必须要知道我们一共为该成员模板函数实例化了多少个不同版本的虚函数。显然编译器需要查找所有的代码文件，才能够知道到底有几个虚函数，这对于多文件的项目来说，代价是非常高的，所以规定成员模板函数不能够为虚函数。  




#### 数组两种声明方式的不同  
- int a[] = {1,2,3}；存放在栈区，内容可变
- int *p = {1,2,3};存放在常量区，其内容不可变，相当于const int a[]   
####  const的作用
- 可以定义const常量
- 便于进行类型检测 const常量由数据类型，宏常量没有数据类型，编译器会对const进行类型检查，对后者只进行字符替换  
- 保护被修饰的东西比如函数里的关键参数
- 为函数重载提供参考
- const定义只有一份拷贝比#define节省空间
- 提高效率，const常量保存在符号表中，是一个编译期间的常量，不会存储和读写
#### const的迷惑点  
- Type const ValueName = value  
const Type valueName = value涵义相同
- 指针使用const    
 char* const pContent;指针本身是常量不可变  
const char *pContenet;指针指向的内容是常量不可变
- 函数中使用const  
void fun(const int var) 传递进的参数不可变  
const int *fun();  
int* const fun(); 函数可以看成一个变量，意义和上面相同
- 类相关const  
==成员变量==不能被修改，只能在初始化列表中赋值  
void fun() const 常==成员函数==，不能修改对象的成员变量，也不能调用类中任何非const成员函数对于const类对象/指针/引用，只能调用类的const成员函数，因此，==const修饰成员函数的最重要作用就是限制对于const对象的使用==。==const成员函数能够访问对象的const成员，而其他成员函数不可以==  
 ==const 修饰类==对象表示该对象为常量对象，其中任何成员都不能被修改。  
const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。  
#### 伪函数  
- 所谓的伪函数。就是说它不是一个真正的函数，而是一个类或者说是一个结构体。  
在使用方法上像是一个类来使用  
- 可以像一个变量一样传递，能够被其他类和成员调用，常见于自定义比较函数  
- 重载（）操作符
```
 bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
```
#### 友元
什么样的函数不能声明为虚函数？1）不能被继承的函数。2）不能被重写的函数。

1）普通函数

普通函数不属于成员函数，是不能被继承的。普通函数只能被重载，不能被重写，因此声明为虚函数没有意义。因为编译器会在编译时绑定函数。

而多态体现在运行时绑定。通常通过基类指针指向子类对象实现多态。

2）友元函数

友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。

3）构造函数

首先说下什么是构造函数，构造函数是用来初始化对象的。假如子类可以继承基类构造函数，那么子类对象的构造将使用基类的构造函数，而基类构造函数并不知道子类的有什么成员，显然是不符合语义的。从另外一个角度来讲，多态是通过基类指针指向子类对象来实现多态的，在对象构造之前并没有对象产生，因此无法使用多态特性，这是矛盾的。因此构造函数不允许继承。

4）内联成员函数

我们需要知道内联函数就是为了在代码中直接展开，减少函数调用花费的代价。也就是说内联函数是在编译时展开的。而虚函数是为了实现多态，是在运行时绑定的。因此显然内联函数和多态的特性相违背。

5）静态成员函数

首先静态成员函数理论是可继承的。但是静态成员函数是编译时确定的，无法动态绑定，不支持多态，因此不能被重写，也就不能被声明为虚函数。 


#### 闭包（导致内存泄露，局部变量无法回收）
https://blog.csdn.net/weixin_43586120/article/details/89456183  
```
struct F2 {
    int x = 1;
    int y = 2;
    int z = 3;
    struct F3 {
        int x;
        int y = 3;
        F3(int x_) : x(x_) {}
        void operator()() const {
            printf("%d %d\n", x, y);
        }
    };
    F3 operator()() const {
        return F3(x);
    }
};
```

闭包就是将函数以及当前的上下文进行绑定，可以使用仿函数或者lamda表达式的方式实现  
- 让外部访问函数内部变量成为可能；
- 局部变量会常驻在内存中；
- 可以避免使用全局变量，防止全局变量污染；
- 会造成内存泄漏（有一块内存空间被长期占用，而不被释放）

每一个闭包创建时都是独立开辟空间，互不影响


```
function outerFn(){
  var i = 0; 
  function innerFn(){
      i++;
      console.log(i);
  }
  return innerFn;
}
var inner = outerFn();  //每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址
inner();
inner();
inner();
var inner2 = outerFn();
inner2();
inner2();
inner2();   //1 2 3 1 2 3
```
从上述代码可以看出，每次创建闭包的时候，都会重新开辟一个常驻空间，并且引用匿名函数的创建时的上下文，所以长期占用的空间就有可能造成内存泄露  

使用仿函数实现时，是显示的创建一个对象存储方法以及从父函数或者父类捕捉的属性，在创建时会显示创建一个仿函数，开辟一块新内存。  

使用lamda表达式，是隐式的创建匿名类，捕获父函数的属性，或者父类的this指针，在创建的时候实例开辟空间。  








---

1，使用new从heap分配的对象为dynamic extent，再运行时通过new分配，因此可以持续存活，直到delete关键字加以释放  
==new和delete是c++提供的关键字，会调用构造函数和析构函数==    

2.静态局部函数变量，即使再不同的函数调用中，依然存在，只在第一次调用时创建，不会因调用结束从栈中释放   

3.inline只是对编译器的一种请求，是否执行需要视编译器而定，将函数的操作改为一份函数代码副本代替，这将节省去调用函数的时间  
==当程序需要频繁调用时，可设为inline，没用压栈开销==   

- 宏函数只是替换字符，再预编译中替换  
- 可读性差
- 没有类型安全的检查

---
- 不分配内存
- 不占运行时间，只占编译时间
- 宏和内联展开回时源程序变长，函数调用不会    

4.iterator（泛型指针）设计了一组iterator class 使用和指针相关的语法，提领运算符，！=，++运算符由iterator内相关的inline函数提供（运算符重载）对指针进行了进一步抽象    

5。析构函数再object结束生命时，便会自动调用用来释放constructor中或对象生命周期中分配的资源，如heap中分配的空间，指针指向的内存地址  
==如何构造一个大小可变的结构体  使用柔性数组，数组大小位置的数组==  
在一个结构体的最后 ，申明一个长度为空的数组，就可以使得这个结构体是可变长的。对于编译器来说，此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量， 数组名这个符号本身代 表了一个不可修改的地址常量 （注意：数组名永远都不会是指针==！ ）柔性数组本质还是一个数组，不需要手动释放    

6。使用另一个对象初始化对象时，需要考虑两个对象中是否由指针指向同一个数据，如果有，需要重新开辟一片空间创建一个副本==避免其中一个对象释放时，另一个对象的数据丢失==  称为==成员逐一初始化==    

7。静态类成员，只在第一次创建对象初始化，之后不再初始化，静态成员函数只能用类型名调用  

8。了解const么？哪些时候用到const？与宏定义有什么差异？（提问概率：★★★★）  
简单理解，const的目的就是定义一个“不会被修改的常量”，可以修饰变量、引用、指针，可以用于函数参数、成员函数修饰。成员变量。使用const可以减少代码出错的概率，我们通常要注意的是区分常量指针（指向常量的指针）和指针常量（地址是常量，指针指向的地址不变）以及合理的在函数参数里面使用。具体的情况可以参考下面的书籍与资料。  
Const用法总结（快速区分指针常量与常量指针）https://blog.csdn.net/u012999985/article/details/49009531  

9。reference和pointer的区别？哪些情况使用pointer？（提问概率：★★）  
- 指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用仅是个别名；
- 引用使用时无需解引用(*)，指针需要解引用；
- 引用只能在定义时被初始化一次，之后不可变；指针可变；
- 引用没有 const，指针有 const；
- 引用不能为空，指针可以为空；
- “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
- 指针和引用的自增(++)运算意义不一样；
- 指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）
- 从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。 
  

10。inline的优劣（提问概率：★★）  
优点：减少函数调用开销  
缺点：增加函数体积，exe太大，占用CPU资源，可导致cache装不下(减小了cache的命中) ，不方便调试debug下一般不内联， 每次修改会重新编译头文件增加编译时间  
注意:inline只是一个请求，编译器有权利拒绝。有7种情况下都会拒绝，虚调用，体积过大，有递归，可变数目参数，通过函数指针调用，调用者异常类型不同，declspec宏等
forceinline字面意思上是强制内联，一般可能只是对代码体积不做限制了，但是对于上面的那些情况仍然不会内联，如果没有内联他会返回一个警告。 构造函数析构函数不建议内联，里面可能会有编译器优化后添加的内容，比如说初始化列表里面的东西。  

11。final和override的作用，以及使用场合（提问概率：★★）  
final:禁止继承该类或者覆盖该虚函数  
override:必须覆盖基类的匹配的虚函数  
场合（final）:不希望这个类被继承，比如vector，编码者可能不够了解vector的实现，或者说编写者不希望别人去覆盖某个虚函数，顾名思义，final就是最终么
场合（override）:第一种，在使用别人的函数库，或者继承了别人写的类时，想写一个新函数，可能碰巧与原来基类的函数名称一样，被编译器误认为要重写基类的函数。第二种情况是想覆写一个基类的函数，但是不小心参数不匹配或者名字拼错，结果导致写了一个新的虚函数  

12。C++03/98有什么你不习惯或不喜欢的用法？C++11有哪些你使用到的新特性？（提问概率：★★★★★）  
auto，有一些迭代器或者map嵌套类型，遍历时比较麻烦，auto写起来很方便。  
vector以及其他容器的列表初始化，原来想要像数组一样初始化的话，需要一个一个来，很麻烦。  
类内初始值问题，总是需要放到构造函数里面初始化，初始化列表倒是不错，但是初始化数据太多就不行了。  
nullptr，C++11前的NULL一般是是这样定义的 #define NULL 0，这可能会导致一些函数参数匹配问题。而nullptr可以避免这个问题。  
thread，不需要再使用其他的库来写多线程了。  
智能指针shareptr，一定程度上解决内存泄露问题。  
右值引用，减少拷贝开销。    

lambda function，简化那些结构简单的函数代码。
当然，你要是能说出一些还没有改正或者有待考虑的问题就更好了，比如内存管理的困难（没有GC），没有反射以及一些C#，java里面有而C++没有的特性等，要能深入一点说那就更好了  

13。Delete数组的一部分会发生什么？为什么出现异常？（提问概率：★★★★）  
- 释放  堆  栈  中c++的基本数据（int char 结构体时）的储存空间时，不管是否使用delete释放，都可以正常释放所有内存空间，不会导致内存泄漏  
- Delete数组的一部分会发生什么？为什么出现异常？ 
VC下是异常，实际删除的时候整个数组的内存不仅仅是数据大小还包括CRTHeader，数组长度等信息。如果删除一部分会从数量的位置开始传入，是有问题的。VC下数组的内存布局参考下面公式，

公式1）_CrtMemBlockHeader + <you date> +gap[nNoMansLandSize];这类数据用delete和delete[]都一样！

公式2）_CrtMemBlockHeader +数组元素个数+ <your date> +gap[nNoMansLandSize];

如果其他编译器，有可能不会报错。但是只释放一个数组对象也是有问题的，其他的对象既没有释放也没有析构。  
参考书籍与资料：为何new出的对象数组必须要用delete[]删除，而普通数组delete和delete[]都一样（https://www.cnblogs.com/sura/archive/2012/07/03/2575448.html）

14。对象数组不能用delete,只能用delete[];  
首先上文可知普通类型数组和对象数组的储存方式并不同，而对象数组之所以不能使用delete的原因是，在将<your data>的首地址传给delete所调用的函数时，会将==数组元素个数==当作 _CrtMemBlockHeader解析，这时在后面检查你的数据类型时发现你的数据类型改变，就会报错  

15。系统是如何知道指针越界的？  （提问概率：★★）
VC下有一个结构体_CrtMemBlockHeader，里面有一个Gap属性，这个Gap数组放在你的指针数据的后面，默认为0xFD，当检测到你的数据后不是0xFD的时候就说明的你的数据越界了。  

16。C++编译器有哪些常见的优化？听说过RVO（NRVO）么？（提问概率：★★★）  
- 1.常量替换如int a = 2; int b = a; return b;可能会优化为 int b=2; return b; 进一步会优化为return 2;
- 
- 2.无用代码消除比如函数返回值以及参数与该表达式完全无关，直接会优化掉这段代码
- 
- 3.表达式预计算和子表达式提取常量的乘法会在编译阶段就计算完毕，相同的子表达式也会被合并成一个变量来进行计算
- 4.某些返回值为了避免拷贝消耗，可能会被优化成一个引用并放到函数参数里面，如RVO，NRVO。
RVO：函数返回的对象如果是新构造的值类型就直接通过一个引用作为参数来构造，进而避免创建一个临时的“temp”对象。  
NRVO：相比RVO进一步优化。对于RVO，如果函数在返回前创建了一个临时变量，这个临时变量还是会被构造的，参考下面代码   

17。成员函数指针了解么？可以转换为Void*么？为什么？（提问概率：★★★）  
void* 可以接收多种指针类型  
不可以用普通指针指向成员函数，需要在类型中加入一个成员指针，它们只能指向一个特定的类中的成员函数。对每一种参数的组合，需要有不同的成员函数指针类型，而且对每种使用const修饰的函数和不同类中的函数，也要有不同的函数指针类型。    
::*用于指针声明  ->*  .*用于调用指向函数，，一个成员函数指针可以被设置成0，并可以使用“==”和“!=”比较运算符，，但只能限定在同一个类中的成员函数的指针之间进行这样的比较。任何成员函数指针都可以和0做比较以判断它是否为空。与函数指针不同，不等运算符（<, >, <=, >=）对成员函数指针是不可用的。  
成员函数指针有时表现得很奇怪。

首先，你不可以用一个成员函数指针指向一个静态成员函数，你必须使用普通的函数指针才行  
允许成员函数指针之间进行转换（cast），而不允许在转换完成后调用其中的函数  
编译器设置不同，有争论，看不懂，不看了  

不可以转换成Void*，因为成员函数指针大小并不是4个字节（32位机器上），除了地址还需要this（指向类信息）的delta，索引等信息。成员函数指针比较复杂，建议好好读一下下面给出的文章。

写法：函数指针 float (*my_func_ptr)(int, char *);

成员函数指针 float (SomeClass::*my_memfunc_ptr)(int,char *);  
参考书籍与资料：
成员函数指针与高性能的C++委托（中文）（https://www.cnblogs.com/jans2002/archive/2006/10/13/528160.html）  

18。描述一下C/C++代码的编译过程？（提问概率：★★★★）  
预处理——编译——汇编——链接。预处理器先处理各种宏定义，然后交给编译器；编译器编译成.s为后缀的汇编代码；汇编代码再通过汇编器形成.o为后缀的机器码（二进制）；最后通过链接器将一个个目标文件（库文件）链接成一个完整的可执行程序（或者静态库、动态库）。  

19。了解静态库与动态库么？说说静态链接与动态链接的实现思路（提问概率：★★★）  
静态库：任意个.obj文件的集合，程序link时，被复制到output文件。这个静态库文件是静态编译出来的，索引和实现都在其中，可以直接加到内存里面执行。

对于Windows上的静态库.lib有两种，一种和上面描述的一样，是任意个.o文件的集合。程序link时，随程序直接加载到内存里面。另一种是辅助动态链接的实现，包含函数的描述和在DLL中的位置。也就是说，它为存放函数实现的dll提供索引功能，为了找到dll中的函数实现的入口点，程序link时，根据函数的位置生成函数调用的jump指令。（Linux下.a为后缀）

动态库：包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。（Linux下.so为后缀）  

20。知道内部链接与外部链接么？（提问概率：★★）  
内部链接：如果一个名称对于他的编译单元是局部的，并且在链接时不会与其他的编译单元中同样的名字冲突，那么这个名称就拥有内部链接。

外部链接：一个多文件的程序中，一个实体可以在链接时与其他编译单元交互，那么这个实体就拥有外部链接。换个说法，那些编译单元（.cpp）中能想其他编译单元（.cpp）提供其定义，让其他编译单元(.cpp)使用的函数、变量就拥有外部链接  

21。extern与static（提问概率：★★★）  
extern 声明一个变量定义在其他文件，这样当前文件就可以使用这个变量，否则会编译失败，如果两个全局变量名称一样会出现链接失败。extern c的作用更重要，因为c+ +的编译方式与c是不同的，比如函数重载利用mangling的优化。static变量，就是在全局声明一个变量判断是否初始化，是的话之后就不做操作了。static成员函数其实在编译后与class完全没有关系。static成员其实也没关系，但是private的需要通过类去调用。static全局只能在本文件使用(内链接)，与其他无关。全局函数变量是外链接，可以跨单元调用。    
　C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。
参考书籍与资料：[C++]实现委托模型（https://www.cnblogs.com/zplutor/archive/2011/09/17/2179756.html）  

22。使用过模板么？了解哪些特性？（提问概率：★★★★）  
模板分为函数模板与类模板，其根本目的是将类型“参数化”，实现编译时的“动态化”，避免重复代码的书写。另一种运行时的“动态化”就是多态。

模板使用常见的特性有“特化”，“偏特化”，“非类型模板参数”，“设置模板参数默认类型”，“模板中的typename的使用”，“双重模板参数Template Template Parameters”，“成员模板Member Template”，理解这些内容我们就基本上可以看STL标准库了。

另外，模板的实例化过程也是需要理解的。  

23。听说过转发构造么？（提问概率：★★）  
通过foward关键字可以同时考虑到参数为左值以及右值的情况，然后把函数的参数完美的转发到其他函数的参数里面。这个里面涉及到左值、右值、move、forward、引用折叠等技术点。  

24。描述一下函数调用过程中栈的变化（提问概率：★★★★）  
回答这个问题需要对栈的使用过程，函数调用，汇编都有一定的理解才行。首先，要清楚一个概念“栈帧”。

栈帧(stack frame)：机器用栈来传递过程参数，存储返回信息，保存寄存器用于以后恢复，以及本地存储。为单个过程(函数调用)分配的那部分栈称为栈帧。栈帧其实是两个指针寄存器，寄存器ebp为帧指针（指向该栈帧的最底部），而寄存器esp为栈指针（指向该栈帧的最顶部）。

然后我们再简单描述一下函数调用的机制，每个函数有自己的函数调用地址，里面会有各种指令操作（这端内存位于“代码段”部分），函数的参数与局部变量会被创建并压缩到“栈”的里面，并由两个指针分别指向当前帧栈顶和帧栈尾。当进入另一个子函数时候，当前函数的相关数据会被保存到栈里面，并压入当前的返回地址。子函数执行时也会有自己的“栈帧”，这个过程中会调用CPU的寄存机进行计算，计算后再弹出“栈帧”相关数据，通过“栈”里面之前保存的返回地址再回到原来的位置执行前面的函数。  

25。C++中四种Cast的使用场景是什么？（提问概率：★★★★★）  
constcast，去掉常量属性以及volatile，但是如果原来他就是常量去掉之后千万不要修改；比如你手里有一个常量指针引用，但是函数接口是非常量指针，可能需要转换一下；成员函数声明为const，你想用this去执行一个函数，也需要用constcast

staticcast，基本类型转换到void，转换父类指针到子类不安全

dynamiccast，判断基类指针或引用是不是我要的子类类型，不是强转结果就返回null，用于多态中的类型转换

reintercast，可以完成一些跨类型的转换，如int到void*，用于序列化网络包数据  


26。dynamic_cast是怎么实现的（提问概率：★★★★）  
dynamiccast属于RTTI,运行时类型识别的一个内容，他是c++realise1.0的主要扩充功能之一。主要内容是typeid与typeinfo的实现,基本思路就是在有虚函数的类的虚表的头部位置存放RTTI的相关信息。在VC里面可以看到是一个叫做RTTI Complete Object Locator的结构体里面存放相关的信息。在强转的时候，会读取里面对应的类的信息进而判断是否能转换成功  


27。 用过或很熟悉的设计模式有哪些？（提问概率：★★★★）     
- 策略模式( Strategy )  
定义个策略接口，不同的实现类提供不同的具体策略算法, 同时它们之间可以互相替换.   
IStrategy 接口定义了策略方法，Strategy1 和 Strategy2 通过实现 IStrategy 提供不同的策略，而 User 组合了 IStrategy ，可以通过给 User 对象设置不同具体实现类来让其获得不同的策略
![image](https://upload-images.jianshu.io/upload_images/714670-eced0d22b6cec597.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

- 简单工厂模式( Simple Factory )  
定义一个用以创建对象的工厂, 根据不同的条件生成不同的对象  
注意简单工厂模式与策略模式是不同的，工厂模式是根据给定的条件返回相应的对象，而策略模式是将不同的策略对象传递给使用者以实现不同策略,（好吧，我差点分不清了）详细不同点分析可转这里  
![image](https://upload-images.jianshu.io/upload_images/714670-74ef7103befae368.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
- 工厂模式( Factory )  
针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例   
与简单工厂模式不同点是它要为每一种产品提供一个工厂类，不同工厂类实现同一个工厂接口，返回不同产品，![image](https://upload-images.jianshu.io/upload_images/714670-49da93168e2c3259.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)  
- 抽象工厂模式( Abstract Factory )  
应对产品族概念而生  
与工厂模式相比，抽象工厂模式是为了应对产品族  
![image](https://upload-images.jianshu.io/upload_images/714670-bc37eae1e142700e.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
- 装饰者模式( Decorator )  
动态的给一个对象添加一些额外的功能  
ComponentImpl 和 Decorator 类都实现了 IComponent 接口，不同的是 ComponentImpl 提供了具体实现，而 Decorator 是先聚合 ComponentImpl 接着在自己的实现方法即 operation() 方法中做些处理（即装饰）后再调用 ComponentImpl 对象的具体实现
![image](https://upload-images.jianshu.io/upload_images/714670-f3ed02ee8863f60b.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
- 代理模式( Proxy )  
封装被代理对象并限制外界对被代理对象的访问  
注意区分装饰者模式和代理模式的区别。在代理模式中，ComponentImpl 和 Proxy 类都实现了 IComponent 接口，Proxy 对象中虽然也维护着一个 ComponentImpl 对象，但一般情况下它是代理类自己初始化的，不像装饰者模式是通过 set 进去的，同时在接口方法即 operation() 中代理对象会限制外界对被代理对象的访问，而装饰者模式是装饰者给被装饰者添加额外的行为，
![image](https://upload-images.jianshu.io/upload_images/714670-dcfa94fd6464407c.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)  
- 模板方法模式( Template )  
定义一个操作的算法骨架, 并将一些步骤延迟到子类中  
AbsTemplate 抽象类中定义了一系列的方法，其中外界唯一能调用的 operation() 方法是 final 的（即不可重写），在该方法中分别调用了 first() 、second() 、third() 方法（即搭好算法框架），子类通过继承抽象类重写不同的方法来添加各自的行为
![image](https://upload-images.jianshu.io/upload_images/714670-414a2199d384655a.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
- 外观模式( Facade )  
为系统向外界提供一个统一的接口  
架构中层与层之间设置Facade类提供统一接口方便外界调用，减少耦合，维护遗留代码
Fracade 为 ComponentA 、ComponentB 、ComponentC 向外即 ClientA 、ClientB 提供统一的接口![image](https://upload-images.jianshu.io/upload_images/714670-cfe0493f0b9e8eda.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
- 适配器模式( Adapter )  
比如项目引入第三方类库后应该先封装起来转换成自己需要的接口再使用，防止以后类库出现变更。AdapterA 先将 LibraryClass 封装起来，其对外提供的 operation() 方法中调用 LibraryClass 对象的方法，若以后换类库，只需改 AdapterA 类或者创建新的 Adapter 实现类即可
![image](https://upload-images.jianshu.io/upload_images/714670-2b85ee5450af9c6c.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/931/format/webp)
- 桥接模式( Bridge )  
将抽象部分与实现部分分离，使它们都可以独立的变化  
将原本要耦合的上下层抽象出来，上层和下层以组合的方式连接，然后上下层抽象可派生出许多不同方向的子类。AbsShape 封装了 IDrawProgram 接口，这样它的子类想从 DPA 切换到 DPB 或者别的，只需 set 进去就行啦（你看，这 UML 图多像座桥）
![image](https://upload-images.jianshu.io/upload_images/714670-efef83a5e8a4c16d.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
- 建造者模式( Builder )  
将一个复杂对象的构建与它的表示分离.  
作为 Product 的内部类，Builder 统一了 Product 的整个构建过程，同时在 build 过程中，可以由于 set 值顺序不同等原因产生不同的效果    
定义一个Bulider接口，然后有多个实现的具体ConcreteBuilder实现类，用户使用Director类控制使用哪个builder方式
![image](https://upload-images.jianshu.io/upload_images/714670-1ea1ac045778fbe8.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)  
- 观察者模式( Observer )  
定义了一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象,在它的状态发生变化时,会通知所有的观察者.  
先将 Observer 注册到 Observable ，那么当 Observable 状态改变时会通知它持有的所有 Observer ,对了，最好 Observable 中的 mList 的泛型是 WeakReference<Observer>  ,防止内存泄漏  
当 一个 对象 的 改变 需要 同时 改变 其他 对象，为了解耦合，可以使用观察者模式，一般观察者模式不使用接口，因为本身

![image](https://upload-images.jianshu.io/upload_images/714670-7516c8a1447d83cc.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
- 单例模式( Singleton )  
保证一个类仅有一个实例,并提供一个访问它的全局控制点.  
下图是利用 Java 的语言特性实现的线程安全且能延迟初始化的单例模式，Singleton 中维护着静态私有的 SingleHolder 类， SingleHolder 类中持有个静态常量 sHolder ，Client 若通过 getSingleInstance 方法获取 Singleton 对象则直接返回 SingleHolder 类的 sHolder   
让类自己保存它的唯一实例，这个类可以保证没用其他时类可以被创建，并且可以提供一个访问该类的方法，即它保存的那唯一一个实例，可以严格的控制客户怎样访问它以及如何访问    
多线程中的单例，多线程中的程序中，多个线程同时访问Singleton类，调用GetInstance（），会有可能创建多个实例，这时候需要使用线程锁   
lock确保当一个线程位于代码的临界区时，另一个线程不进入临界区，如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放  
双重锁定锁  
双重锁定的意义是避免每次线程都被隔离在临界区之外，因为只有当instance为null然后多个线程访问时才会导致创建出多个实例，因此只在instance为null时加锁就可  
  

饿汉模式 可使用静态构造函数或者静态字段字段

```
class Singleton
{
	private static Singleton instance;
	private static readonly object syncRoot = new object();
	private Singleton()
	{
	}
	public static Singleton GetInstance()
	{
		if (instance == null)
		{
			lock(syncRoot)
			{
				if (instance == null)
				{
					instance new Singleton();
				}
			}
		}
		return instance;
	}
};
```

![image](https://upload-images.jianshu.io/upload_images/714670-6712adfb98766e84.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

- 命令模式( Command )  
将一个请求封装成为一个对象, 使可以用不同的请求对客户进行参数化  
Action 封装了具体行为，Command 封装了 Action 并提供空方法 execute() ，它的子类通过重写该方法可在方法里调用 mAction 不同行为达到封装命令的目的，最后 Client 封装了一系列的 Command 对象，并可以通过 notify() 方法一个接着一个调用所持有 Command 对象们的 execute() 方法达到给 Action 传达命令的目的
![image](https://upload-images.jianshu.io/upload_images/714670-cc202a26178f3b09.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)


28。virtual function的优缺点（提问概率：★★★★）  
优点：实现多态
缺点：MFC中的消息机制以及Qt中都没有采用C++中的虚函数机制，原因大概如下~

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.在子类很少覆盖基类函数实现的时候内存开销太大，每个类需要产生一张虚表，每生成一个对象的时候，需要在对象里存放一个vptr。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.基类指针指向派生类对象的情况下，无法内联优化

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.在执行效率上肯定多了一些开销，需要寻找函数地址4.虚表的存在可能破坏一些封装安全，可以通过vptr绕过private的限制  

29。多继承的优缺点（提问概率：★★★）  
好处：简单来讲就是为了实现多个基类特有的功能

缺点：菱形继承；二义性  

30。为什么要用virtual destructor?为什么没有virtual constructor?（提问概率：★★★★）  
第一点，构造函数执行前，对象的内存信息都没有，vptr也没有初始化，如何找到虚函数表，实现虚调用。其次，需要理解虚函数的意义，他是为了实现多态，让子类去覆盖父类的操作，但是前提是你需要知道当前的类型是什么，而C++里面构造函数可以说决定了他的类型。另外，构造函数与析构函数的执行不同，他是从父类开始一步一步的构造成一个子类(即使父类没有构造函数也可能会被编译器合成一个)，所以你不能跳过父类的构造函数，子类的很多成员可能需要在父类的基础上去初始化。  
并且基类指针指向派生类时我们，如果没有virtual destructor就会调用基类的析构函数，无法释放派生类中的数据成员，所以有虚函数的类必须将destructor也声明为virtual  

31。类的内存布局是什么样的？考虑有虚函数、多继承、虚继承几种情况。（提问概率：★★★★★）

  简单总结一下就是类只有成员变量占用内存（静态成员不占类内部内存，函数不占内存）。如果有虚函数，每个类对象都会有一个虚函数指针Vptr（占用一个指针大小的内存），vptr指向一个虚函数表，表里面记录了各项标记virtual的函数，子类如果覆盖父类虚函数，对应虚表位置的虚函数会被子类的替换（虚表在运行时其位置与大小就被决定了，一个类只有一个虚表）  
  菱形继承问题  引入虚继承，增添一个指针，函数名称覆盖，又派生类显示调用超类构造函数

32。C+ +内存管理相关C+ +内存模型是什么？如何理解自由存储区与堆的区别？（提问概率：★★★★）  
在C+ +中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区。malloc在堆上分配的内存，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放，不过这只是表象。进一步来讲，基本上所有的C+ +编译器默认使用堆来实现自由存储，即缺省的全局运算符new和delete也会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。
所以，new所申请的内存区域在C++中称为自由存储区，如果是通过malloc实现的，那么他也是在堆上的。  

33。memory alignmentand padding, 内存对齐的原理与意义（提问概率：★★★★）  
结构体以及类成员对齐，意义就是减少cpu读取的次数，提高效率。比如一个int变量长度为4个字节，cpu一次读4个字节，当然是一次读取比较好。但是如果前面有一个char，地址为0-1。那么这个int的地址就为1-4。导致cpu，分两次读取int值。
具体的对齐规则，要说的非常准确可能比较麻烦，简单来讲就是，每个变量看后面的变量，如果后面的变量大，就和后面的大小对齐并补充字节。最后一个变量，按照成员内最大的对齐值，对齐并补充字节。  
处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.假如没有内存对齐，获取一个4字节的int数据可能需要2次读取，并且需要剔除其中不需要的bit位，消耗太多资源  
#pragma pack系统指定数值和自身数据长度中较小的整数倍  

34。std::shared_ptr的实现，reference count在哪里定义（提问概率：★★★）  
shared_ptr作为一种智能指针，本质上一个模板类，表现上与指针相同，是因为重载了&以及*这两个运算符（当然还有=等运算符）。由于其本身的计数机制，防止资源泄露上面很有意义。
Shareptr在实现上有两个核心的成员，一个是指向资源对象的指针变量，另一个是指向引用计数的指针变量。第一个参数不言而喻，第二个参数为什么也是指针？因为多个shared_ptr对象指向同一资源时，其中一个shared_ptr对象析构了count = count -1,是不会影响到其他shared_ptr对象的，所以使用指针可以达到多个shared_ptr对象指向同一资源的能够共享count目的。另外，原生的shared_ptr的读写在多线程当中是不安全的，因为读写不具有原子性，所以多线程使用shared_ptr一定要加锁。循环引用会造成内存泄露。  
原始指针智能初始化一个智能指针，不然会导致二次析构

35。new expression,operator new和malloc的联系（提问概率：★★★★）  
malloc：是从C语言移植过来的语义，表示申请一定大小的内存并返回void*指针，在堆上申请内存，申请失败会返回Null  
new：C++里的关键字，针对对象而言，申请一块内存的然后并在内存上构造对应的对象，最后返回该对象的指针。深入：new是从自由存储区分配的内存，自由存储区可能不在堆上，在静态存储区（全局变量做的对象池）。申请失败会抛出异常。可以通过new[]对数组进行内存申请与构造  
Operator new：C ++里面与Malloc类似的语义，只申请内存而不构造对象
New操作的第一步就是调用OperatorNew来执行内存的申请。深入：operator new可以基于malloc实现，一般也都是这么做的，可以被重载  
- 你想在堆上建立一个对象，应该用new操作符。它既分配内存又为对象调用构造函数。
- 假设你只想分配内存，就应该调用operator new函数；它不会调用构造函数。
- 假设你想定制自己的在堆对象被建立时的内存分配过程，你应该写你自己的operator new函数。然后使用new操作符，new操作符会调用你定制的operator new。
- 假设你想在一块已经获得指针的内存里建立一个对象。应该用placement new。
- 调用operator new 获得内存和operator delete释放内存给系统（搭配使用）
- placement new 建立的对象，不能用delete释放，因为对象的内存最初不是被operator new分配的，应该显式的调用析构函数然后再调用free释放内存  
  

36。placement new的意义（提问概率：★★★）  
placement new作用不太像new，或者说只是一个不完整的new，因为他不分配内存，只是在给定地址上调用构造函数，在c++里面，placement new实际上就是operator new的一种重载方式之一。
一个普通的new可以拆分成两步，第一步，申请内存返回指针，执行一个非placement的operator new(可能通过malloc实现)。第二步，在指定位置上构造对象(这个操作一般是编译器帮我们做了，但是并不是执行placement new，虽然功能上差不多，这里面有细微的差别)。c+ +单独提供给我们一个placement new 来做第二步操作，因为有的时候我们可能想使用自己的内存申请方式(比如malloc)，但是你发现除了placement new以外你好像没有其他办法在指定位置上调用构造函数。
另外，想要使用placement new，底层系统并不告诉你这个地址上是否已经有对象了，如果你在已经构造的对象上面执行，那么前一个对象就会被销毁，理论上析构函数也不会执行。总之，要避免这种情况。  

37。allocator的实现与使用意义（提问概率：★★★）  
c++11新标准里面加入，他本身是一个类模板，功能上其实就是把new拆开，把内存申请和对象构造分成两个步骤，是不是很熟悉？这不就是operator new和placement new么？实际上allocator就是利用operator new来实现的。
为什么要这么做？举个例子，假如我要new一个长度为100的string数组，那我在申请内存的同时还要构造100个string对象，而实际上我整个程序从开始到结束可能只用了10个string。那为了减小构造的开销，这里就将内存申请与对象构造分开，也就有了allocator。当然，我们也可以使用operator new来做这个操作，只不过allocator帮我们做了一些简单的封装，类型检查等。另外，说到allocator就不得不提一下stl里面的空间配置器alloc，他除了上面简单的封装外还还考虑到了以下三个方面：1.多线程内存分配(内存池互斥访问)2.内存分配失败的异常处理3.实现一个轻量级内存池来解决小块内存导致的内存碎片问题
第一种情况，基本的实现就是在构造时加锁，析构时解锁。
内存分配失败的话，给用户提供一个函数去定义异常时的处理逻辑。
针对内存碎片问题，sgi stl里面的allocator里面设计了一个双层配置器，当申请内存超过128byte，就认为足够大，直接调用malloc分配。反之，调用第二级配置器使用内存池来处理，内存池实现思路就是先申请一块比较大的内存，分成n块，每次有小的内存申请时就给他一块。  

38。RAII是什么？有什么意义？应用场景？（提问概率：★★★★）  
RAII 是 resource acquisition is initialization 的缩写，意为“资源获取即初始化”。其核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。常见的例子就是智能指针，通过声明一个包含资源对象指针的类，在这个类执行析构的时候释放指针指向的对象。  

39。指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费

检测:windows可以使用crtdumpmemoryleaks替换free为freedebug还可以使用crtmemcheckpoint结合difference比较。

避免:智能指针，如ue垃圾回收机制。  

40。成员函数调用delete this会发生什么？之后再进行读写会怎么样？（提问概率：★★★★）  
在类的成员函数中能不能调用delete this？答案是肯定的，能调用，而且很多老一点的库都有这种代码。假设这个成员函数名字叫release，而delete this就在这个release方法中被调用，那么这个对象在调用release方法后，还能进行其他操作，如调用该对象的其他方法么？答案仍然是肯定的，调用release之后还能调用其他的方法，但是有个前提：被调用的方法不涉及这个对象的数据成员和虚函数。

如果这时候调用普通的成员函数应该没有问题，因为这些成员函数与普通函数区别不大也在代码段，也需要走函数栈的逻辑。

如果调用虚函数，那就需要获取类内存的虚函数指针，这就涉及到堆内存的操作了，因为这时候虚函数指针也会被设置成未初始化的值，会有问题。

如果操作非指针成员变量，可能读和写都没有问题。

如果操作指针成员变量，指针可能设置成未初始化的值，很可能指向不合法的地方，强制赋值可能会导致崩溃

简单来说就是不要再去操作他的内存数据，否则很有可能崩溃，因为释放后，这个内存不确定系统如何处理。

另外，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。  

41。STL相关。vector的实现与增长（提问概率：★★★★★）  
vector是stl提供的动态数组，想了解他就要从他的特性开始分析。首先，他是一个模板类，意味着可以存放各种类型的元素，同时他也是一个数组，存储是连续的。 里面保存了三个指针，分别指向头、数据尾、数组尾。
内存分配:常规的数组必须在定义的时候就分配好固定的大小，而vector可以动态的改变，也就说明他可以动态的申请与释放内存。我们要知道，频繁的申请与释放内存对程序的效率影响是非常大的，因为如果当前地址空间不够用的话，就需要重新找一块更大的空间来装数据，再把数据全部都拷贝过去。所以vector为了达到比较好的效果，在添加元素的时候会多申请一定大小的内存，从而减少内存分配的次数。capacity()返回的就是包括缓冲区在内的空间大小，而size()返回的就是当前实际使用的空间大小。如果想主动的提前分配内存，可以使用reserve(n)，会强制重新分配一次内存，超出实际使用的部分就会成为缓存区。如果想直接构造出长度为n的动态数组可以使用resize(n)，实际分配的空间肯定要比n大，不过如果n比当前size小的话，大于size的数据都会被清空，如果比capacity还大的话就会重新执行一次内存分配。
关于内存释放，如果只是简单的调用 clear()全部清空数据,erase()清空部分数据都只是单纯的清空里面的数据并不会释放掉。默认只会在调用vector的析构函数的时候才会真正释放空间，所以如果想强制释放那就新建一个空的vector，然后对这个vector使用swap讲内存交换，那么原来的vector就会释放，新的vector呢？
另外，由于涉及到模板，也就会涉及到迭代器，凡是重新申请过内存，插入删除数据的，迭代器都会失效，理解上也很容易就是指针可能指向的不是你原来的那个位置了。  

42。map的实现 unordered_map的原理；如果从空的table开始一直增加元素，会出现什么情况？（提问概率：★★★★★）  
map分为有序map和无序map（unordered_map），实现的基本数据结构分别是红黑树与哈希表。(set同理)里面每一个元素是一个pair< const key_type,mapped_type >类型，注意key是const的，不可以修改。对于一个数据结构，常见的操作无非是查找，插入，删除。红黑树作为一种二叉搜索树，具有log(n)的查找效率，不过前提是数据具有足够的随机性。！！！  
hashmap理想上则是具有常数平均时间的效率，或者说一次或几次就可以查到，当然如果数据量过大，散列表空间就不能和数据量保持1：1，这时候就要靠hash函数来处理数据，将数据尽可能的分散在不同的桶bucket里面。
sgi stl的hash使用的是开链操作来避免hash表空间过大又想保持一定效率的问题，开链就是在一个位置用链表来存储所有冲突项。其实hashmap里面常说的桶bucket就是vector数组的一个元素，每个桶里面的数据是以链表(开链)的形式存储，进一步来说这些操作与定义都是通过一个基本的数据结构hashtable来实现的，所有的无序关联容器都是。hashtable里面的hash函数就是常说的取模函数，根据存储数据key值(注意，是对key而不是value)对桶的长度取余数来存放。默认提供的hash函数无法处理常见内置类型以外的数据，如各种自定义类，其实string本身也算是特殊类型，但是语言内部可以转为const char*处理，他经过函数处理也会得到一个size类型（一般对字符串的哈希函数比较特别，参考各种字符串Hash函数比较）。  
什么时候需要rehash？当你的桶里面的平均数量 ==（Map大小/桶的数量）大于max==(这个可以自己设置)，就需要rehash。也可以主动调用rehash(n),保证桶的数量大于n，注意n是桶的数量。改变桶的数量就相当于改变Vector的长度，如果超过vector的capacity就会调用Vector的扩容机制（但是实际上他每次hash的时候都会直接调用vector的reserve进行扩容）。  
什么时候执行reserve（Java里好像是resize）？注意reserve与vector的reserve不一样，他的目的并不是扩容，而是希望当前哈希表里面可以容纳n个元素。如果n>桶的数量*负载因子的时候就会触发rehash，否则不会触发。rehash有可能进一步触发vector的扩容。  


43。stl里deque是如何实现的？（提问概率：★★★）  
其实deque由一段一段内存构成的，他是分段连续,而不是内存连续。当走向段的尾端时候自动跳到下一段。map记录着一系列的固定长度的数组的地址，这个map仅仅保存的是数组的地址,真正的数据在数组中存放着。deque先从map中央间的位置(因为双向队列，前后都可以插入元素，前面需要留出一定的空间)找到一个数组地址，向该数组中放入数据，数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map,把原来map中的内容copy的新map中。所以使用deque的复杂度要大于vector，尽量使用vector。  

44。stl里heap与priority_queue？（提问概率：★★）  
heap是基于vector来实现的，不过他不属于容器组件，因为他的主要是为优先级队列priority_queue的实现提供基础结构。所谓的优先级队列，其实就是队首元素一定是当前队列中优先级最高的那一个，只能通过 top() 函数来访问队首元素。我们知道最大堆与最小堆拥有这种特性，所以很适合用来实现priority_queue，当然其他数据结构也可以实现，不过从实现复杂度与计算复杂度等方面heap最为合适。  

45。stl里面各个容器的基础数据结构是？（提问概率：★★★★）  
常问的是优先级队列，hashmap，map底层的数据结构是什么。答案分别是Vector，hashtable以及RB—tree（红黑树）

46。拷贝构造函数被调用的3个时机  
 （1） 直接初始化或拷贝初始化；

（2）将一个对象作为一个实参传递，形参采用非指针或非引用的对象进行接收时（指针即指向了同一块空间，并未实现拷贝；而引用就是实参本身）；

（3）函数的返回值是以值传递的形式返回。  

47。  请你来说一下一个C+ +源文件从文本到可执行文件经历的过程？  
对于C++源文件，从文本到可执行文件一般需要四个过程：  
预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。    

编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件  

汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件

链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件


48。请你来回答一下include头文件的顺序以及双引号””和尖括号<>的区别？  
双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。  

对于使用双引号包含的头文件，查找头文件路径的顺序为：
当前头文件目录  
编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）  
系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径  

对于使用尖括号包含的头文件，查找头文件的路径顺序为：  
编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）  
系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径  

49。请你回答一下malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？  
Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。

当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。  

Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。  


​    
50。请你说一说C+ +的内存管理是怎样的？    
在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。
代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。

数据段：存储程序中已初始化的全局变量和静态变量

bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。

堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。

映射区:存储动态链接库以及调用mmap函数进行的文件映射

栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值

51。请你来回答一下什么是memory leak，也就是内存泄漏

1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.

2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。


52。请问C+ +11有哪些新特性？    C+ +11 最常用的新特性如下：
- auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导
- nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。

- 智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。

- 初始化列表：使用初始化列表来对类进行初始化

- 右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率  
移动

- atomic原子操作用于多线程资源互斥操作

- 新增STL容器array以及tuple

53。请你详细介绍一下C++11中的可变参数模板、右值引用和lambda这几个新特性。
- 可变参数模板：  
C++11的可变参数模板，对参数进行了高度泛化，可以表示任意数目、任意类型的参数，其语法为：在class或typename后面带上省略号”。  

```
Template<class ... T>
void func(T ... args)
{
cout<<”num is”<<sizeof ...(args)<<endl;
}
```
func();//args不含任何参数

func(1);//args包含一个int类型的实参

func(1,2.0)//args包含一个int一个double类型的实参

其中T叫做模板参数包，args叫做函数参数包  
省略号作用如下：

1）声明一个包含0到任意个模板参数的参数包

2）在模板定义得右边，可以将参数包展成一个个独立的参数  
C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。    

移动语义：

![image](https://pic4.zhimg.com/v2-7090a554aef03f6c4ae146e975a7c9e3_r.jpg)
直接接收被移动对象的内存，这时候原对象处于“有效但未定义”的状态，所以通常清理她或者不在去访问。


```
std::vector<int> get_vector(int sz)
{
    std::vector<int> vec(sz, 0); // 全部填0
    return vec;
}
vector<int> ans = get_vector(n);
```
为按照引用传递的化，返回值会被析构，并且ans会重新构造n次，在使用右值引用后固定下来，不会析构，并且根据移动语义，ans不用重新构造  
可以看到，当vec_red被赋值时，编译器调用的是它的移动赋值函数，其参数为一个右值引用vector&&。  

左值  
- 有名字的变量；
- 可以取地址的变量；
- 指针解引用的值（使用语言内置的*或->运算符）

右值
- 字面值（literal），比如1， true， nullptr
- 非引用类型的函数返回值；
- 各种内置的运算符组合表达式的计算结果。

右值可以被右值引用绑定，后基于参数类型不同进行函数重载的机制，程序员就可以针对右值引用编写重载函数，从而达到利用右值的目的，右值引用的目的就是不改变原有数据的属性，左值右值属性不被修改。

、
完美转发forward
```
#include <iostream>

template<typename T>
void print(T & t){
    std::cout << "左值" << std::endl;
}

template<typename T>
void print(T && t){
    std::cout << "右值" << std::endl;
}

template<typename T>
void testForward(T && v){
    print(v);
    print(std::forward<T>(v));
    print(std::move(v));
}

int main(int argc, char * argv[])
{
    testForward(1);

    std::cout << "======================" << std::endl;

    int x = 1;
    testFoward(x);
}
```

```
左值
右值
右值
=========================
左值
左值
右值
```
从上面第一组的结果我们可以看到，传入的1虽然是右值，但经过函数传参之后它变成了左值（在内存中分配了空间）；而第二行由于使用了std::forward函数，所以不会改变它的右值属性，因此会调用参数为右值引用的print模板函数；第三行，因为std::move会将传入的参数强制转成右值，所以结果一定是右值。  

再来看看第二组结果。因为x变量是左值，所以第一行一定是左值；第二行使用forward处理，它依然会让其保持左值，所以第二也是左值；最后一行使用move函数，因此一定是右值。

- 左值引用只能接收左值，右值引用只能接收右值。  
- 函数返回值类型和接收类型保持一致，可以减少传递的拷贝次数





  
