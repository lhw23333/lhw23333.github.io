[TOC]
### 二叉搜索树（BST）  
https://blog.csdn.net/isunbin/article/details/81707606
- 完全二叉树，所有节点尽量填满树的每一层，上一层填满后还有剩余节点的话，则由左向右尽量填满下一层。如上图BST所示，即为一颗完全二叉树；  
- 每一层只有一个节点的二叉树。
##### 构造复杂度
- 查询节点过程是，比较元素值是否相等，相等则返回，不相等则判断大小情况，迭代查询左、右子树，直到找到相等的元素，或子节点为空，返回节点不存在  
- 插入节点的过程是，比较元素值是否相等，相等则返回，表示已存在，不相等则判断大小情况，迭代查询左、右子树，直到找到相等的元素，或子节点为空，则将节点插入该空节点位置。
由此可知，单个节点的构造复杂度和查询复杂度相同，为 ~。  
==O(log_2 n)~O(n)。== 
##### 删除复杂度
- 待删除节点度为零；直接删除
- 待删除节点度为一；左子树或者右子树上移
- 待删除节点度为二。  
- 1.查找出左子树中的最大值节点 Node_{max}  
2.替换待删除节点 node 的值为 Node_{max} 的值  
3.删除 Node_{max} 节点因为 Node_{max} 作为左子树的最大值节点，所以节点的度一定是 0 或 1，所以删除节点的情况就转移为以上两种情况。

##### 平衡调整
- LL型调整：  ①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)。  
![image](https://img-blog.csdn.net/20150818221513880)

```
BTNode *ll_rotate(BTNode *y)
{
    BTNode *x = y->left;
    y->left = x->right;
    x->right = y;   
 
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
 
    return x;
}
```
-  RR型调整：将A的右孩子B提升为新的根结点；  
将原来的根结点A降为B的左孩子  
各子树按大小关系连接(AL和BR不变，BL调整为A的右子树)。
![image](https://img-blog.csdn.net/20150818220942825)

```

BTNode *rr_rotate(struct Node *y)
{
    BTNode *x = y->right;
    y->right = x->left;
    x->left = y;
    
 
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
 
    return x;
}
 
```
- LR型调整：  由于在A的左孩子(L)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1变为2。图5是LR型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。 
![image](https://img-blog.csdn.net/20150818224419149) 

```

BTNode* lr_rotate(BTNode* y)
{
    BTNode* x = y->left;
    y->left = rr_rotate(x);
    return ll_rotate(y);
}
```
- RL型调整：  由于在A的右孩子(R)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图7是RL型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。
![image](https://img-blog.csdn.net/20150818230041580)

```
Node* rl_rotate(Node* y)
{
    Node * x = y->right;
    y->right = ll_rotate(x);
    return rr_rotate(y);
}
 
```

### 2-3-4树
#### 2-3-4 树介绍
2-3-4树每个节点最多有四个字节点和三个数据项，名字中 2,3,4 的数字含义是指一个节点可能含有的子节点的个数。对于非叶节点有三种可能的情况：

　　①、有一个数据项的节点总是有两个子节点；

　　②、有二个数据项的节点总是有三个子节点；

　　③、有三个数据项的节点总是有四个子节点；

　　简而言之，非叶节点的子节点数总是比它含有的数据项多1。如果子节点个数为L，数据项个数为D，那么：L = D + 1
　　
　　![image](https://pic4.zhimg.com/80/v2-d8398cbf8169b3c0c7e6d2d7756b3d53_720w.jpg)
　　
#### 插入2-3-4树
新的数据项一般要插在叶节点里，在树的最底层。如果你插入到有子节点的节点里，那么子节点的编号就要发生变化来维持树的结构，因为在2-3-4树中节点的子节点要比数据项多1。

　　插入操作有时比较简单，有时却很复杂。

　　①、当插入没有满数据项的节点时是很简单的，找到合适的位置，只需要把新数据项插入就可以了，插入可能会涉及到在一个节点中移动一个或其他两个数据项，这样在新的数据项插入后关键字值仍保持正确的顺序。   
②、如果往下寻找插入位置的途中，节点已经满了，那么插入就变得复杂了。发生这种情况时，节点必须分裂，分裂能保证2-3-4树的平衡。

节点分裂  
一、创建一个新的空节点，它是要分裂节点的兄弟，在要分裂节点的右边；

　　二、数据项C移到新节点中；

　　三、数据项B移到要分裂节点的父节点中；

　　四、数据项A保留在原来的位置；

　　五、最右边的两个子节点从要分裂处断开，连到新节点上。
　　
　　![image](https://pic3.zhimg.com/80/v2-e7a9406596e6cb07f3eeef0c970901b6_720w.jpg)


根的分裂  
如果一开始查找插入节点时就碰到满的根节点，那么插入过程更复杂：

　　①、创建新的根节点，它是要分裂节点的父节点。

　　②、创建第二个新的节点，它是要分裂节点的兄弟节点；

　　③、数据项C移到新的兄弟节点中；

　　④、数据项B移到新的根节点中；

　　⑤、数据项A保留在原来的位置；

　　⑥、要分裂节点最右边的两个子节点断开连接，连到新的兄弟节点中。
　　
　　![image](https://pic2.zhimg.com/80/v2-dae5c1802da21fe22c4b6d8cb366fce1_720w.jpg)   
　　
　　注意：插入时，碰到没有满的节点时，要继续向下寻找其子节点进行插入。如果直接插入该节点，那么还要进行子节点的增加，因为在2-3-4树中节点的子节点个数要比数据项多1；如果插入的节点满了，那么就要进行节点分裂。下图是一系列插入过程，有4个节点分裂了，两个是根，两个是叶节点：  
　　![image](https://pic4.zhimg.com/80/v2-72ec1d0750dedd0a00ec17380cb514cb_720w.jpg)


### BT红黑树
https://zhuanlan.zhihu.com/p/91960960
红黑树是一种自平衡二叉查找树。它的统计性能要好于平衡二叉树（AVL树），，它可以在O(log n)时间内做查找，插入和删除等操作。红黑树结点数与树高的约束：lg(n+1) >= h/2
- 性质一：节点是红色或者是黑色；
在树里面的节点不是红色的就是黑色的，没有其他颜色，要不怎么叫红黑树呢，是吧。
- 性质二：根节点是黑色；
根节点总是黑色的。它不能为红。
- 性质三：每个叶节点（NIL或空节点）是黑色；
这个可能有点理解困难，可以看图：
![image](https://img-blog.csdn.net/20170324134210046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU3VuX1RUVFQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
- 性质四：每个红色节点的两个子节点都是黑色的（也就是说不存在两个连续的红色节点）；
- 性质五：从任一节点到其没个叶节点的所有路径都包含相同数目的黑色节点；



### 2-3-4树和红黑树
应用如下三条规则可以将2-3-4树转化为红黑树：

　　一、把2-3-4树中的每个2-节点转化为红-黑树的黑色节点。

　　二、把每个3-节点转化为一个子节点和一个父节点，子节点有两个自己的子节点：W和X或X和Y。父节点有另一个子节点：Y或W。哪个节点变成子节点或父节点都无所谓。子节点涂成红色，父节点涂成黑色。

　　三、把每个4-节点转化为一个父节点和两个子节点。第一个子节点有它自己的子节点W和X；第二个子节点拥有子节点Y和Z。和前面一样，子节点涂成红色，父节点涂成黑色。

红黑树转化为2-3-4树只需要将红节点提高一个层次

##### 插入节点后的平衡调整
- 当前节点的父节点是红色，且祖父节点的另一个子节点（叔叔节点）也是红色  
 对策 :把父节点和叔叔节点变黑，爷爷节点涂红，然后把当前节点指针给到爷爷，让爷爷节点那层继续循环，接受红黑树特性检测。
![image](https://upload-images.jianshu.io/upload_images/272719-0dfea938f1dda8c8.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/979/format/webp)
- 当前节点的父节点是红的，叔叔节点是黑的，当前节点是父节点的右子树。  
对策：当前节点的父节点作为新的当前节点，以新当前指点为支点左旋
![image](https://upload-images.jianshu.io/upload_images/272719-aa26a912e75ad3de.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/978/format/webp)
- 当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左儿子  
对策： 父节点变黑，祖父变红，以祖父节点为支点右旋
![image](https://upload-images.jianshu.io/upload_images/272719-e0b15a51609ac829.PNG?imageMogr2/auto-orient/strip|imageView2/2/format/webp)
![image](https://pic3.zhimg.com/v2-36af4bd9f695551261f547c27ffce862_r.jpg)