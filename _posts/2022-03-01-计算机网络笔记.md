<!-- TOC -->

- [3种常见的计算机体系结构划分](#3种常见的计算机体系结构划分)
        - [每一层的协议如下：](#每一层的协议如下)
        - [每一层的作用如下：](#每一层的作用如下)
        - [IP地址的分类](#ip地址的分类)
- [ARP & RAPR](#arp--rapr)
        - [ARP是地址解析协议，简单语言解释一下工作原理（自学习过程）](#arp是地址解析协议简单语言解释一下工作原理自学习过程)
        - [针对不同包的解决方式](#针对不同包的解决方式)
        - [描述RARP](#描述rarp)
- [各种协议](#各种协议)
- [TCP三次握手和四次挥手的全过程](#tcp三次握手和四次挥手的全过程)
        - [TCP的几种形式](#tcp的几种形式)
        - [三次握手：](#三次握手)
        - [四次握手：](#四次握手)
        - [TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？](#tcp的三次握手过程为什么会采用三次握手若采用二次握手可以吗)
        - [超时重传机制](#超时重传机制)
        - [TCP和UDP的区别](#tcp和udp的区别)
        - [TCP对应的协议和UDP对应的协议](#tcp对应的协议和udp对应的协议)
        - [TCP滑动窗口协议](#tcp滑动窗口协议)
        - [拥塞控制和流量控制的区别](#拥塞控制和流量控制的区别)
        - [TCP拥塞控制](#tcp拥塞控制)
        - [http中浏览器一个URL的流程，这个过程中浏览器做了什么，URL（统一资源定位符）包括哪三个部分？](#http中浏览器一个url的流程这个过程中浏览器做了什么url统一资源定位符包括哪三个部分)
- [什么是Socket](#什么是socket)
- [网络中进程如何通信](#网络中进程如何通信)
        - [本地进程通信](#本地进程通信)
        - [网络中进程如何通信](#网络中进程如何通信-1)
- [Socket怎么通信](#socket怎么通信)
        - [接收缓冲区与发送缓冲区](#接收缓冲区与发送缓冲区)
        - [面向连接](#面向连接)
        - [无连接](#无连接)
- [TCP/IP协议](#tcpip协议)
        - [概念](#概念)
        - [TCP的粘包问题以及数据的无边界性：](#tcp的粘包问题以及数据的无边界性)
            - [什么时候需要考虑粘包问题](#什么时候需要考虑粘包问题)
            - [发送粘包的原因](#发送粘包的原因)
            - [解决办法](#解决办法)
            - [封包和拆包](#封包和拆包)
            - [怎样封包和拆包](#怎样封包和拆包)
        - [TCP数据报结构](#tcp数据报结构)
        - [三次握手](#三次握手)
        - [四次握手](#四次握手)
        - [优雅的断开连接–shutdown()](#优雅的断开连接shutdown)
- [OSI模型](#osi模型)
- [Socket常用函数接口及其原理](#socket常用函数接口及其原理)
        - [socket缓冲区以及阻塞模式](#socket缓冲区以及阻塞模式)
- [网络游戏编程](#网络游戏编程)
    - [TCP内部的工作原理](#tcp内部的工作原理)
    - [再UDP上建立虚拟连接](#再udp上建立虚拟连接)
    - [lockstep](#lockstep)
        - [状态同步](#状态同步)
        - [帧同步（lockstep）](#帧同步lockstep)
            - [P2P 模型 (DOOM)](#p2p-模型-doom)
            - [Packet Server (包的简单中继)](#packet-server-包的简单中继)
            - [Client Server (Quake I/II/III)CS架构](#client-server-quake-iiiiiics架构)
        - [混合同步模式](#混合同步模式)
        - [状态同步和帧同步区别](#状态同步和帧同步区别)
        - [同步问题中的预表现](#同步问题中的预表现)

<!-- /TOC -->


https://www.jianshu.com/p/066d99da7cbd
https://blog.csdn.net/ssh520mxd/article/details/107152173  ，，，问题汇总  
    https://www.cnblogs.com/xueweihan/p/5452873.html TcpVSUdp  
https://www.jianshu.com/p/6c73a4585eba  如何使用Udp实现可靠传输
### 3种常见的计算机体系结构划分
- OSI分层（7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
- TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。
- 五层协议（5层）：物理层、数据链路层、网络层、运输层、应用层。

##### 每一层的协议如下：
- 物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关）
- 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）
- 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）
- 传输层：==TCP、UDP==、SPX
- 会话层：NFS、SQL、NETBIOS、RPC
- 表示层：JPEG、MPEG、ASII
- 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS
##### 每一层的作用如下：
- 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
- 数据链路层：将比特组装成帧和点到点的传递（帧Frame）
- 网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
- 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
- 会话层：建立、管理和终止会话（会话协议数据单元SPDU）
- 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
- 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）
#####  IP地址的分类  
IP地址由32位组成，前面16位为网络号，后面16位为主机号  
- A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；
- B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；
- C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；  
==IP地址与子网掩码相与得到主机号==

### ARP & RAPR
##### ARP是地址解析协议，简单语言解释一下工作原理（自学习过程）
1. 每一个主机中都会在ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2. 源地址发送数据时，首先查表，有则发包，无则广播，向本网段的所有主机发送ARP数据包。
3. 本网段其他主机收到时，检查包内IP地址是否为自己的IP地址，如果是，写入或者覆盖ARP列表，然后将自己的MAC地址写入ARP响应包，告诉源地址
4. 源主机找到ARP响应包。根据ARP地址解析协议工作  
##### 针对不同包的解决方式
1. 已知包 直接发
2. 广播包 广播 每一个主机都响应（255.255.255.255）
3. 未知包 广播 查找到后，目标地址响应
##### 描述RARP
RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。

### 各种协议
- ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息
- TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务
- HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统
- DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段
- NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术
- DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段

### TCP三次握手和四次挥手的全过程
##### TCP的几种形式 
SYN表示建立连接，  
FIN表示关闭连接，  
ACK表示响应，  
PSH表示有数据传输，  
RST表示连接重置！  

##### 三次握手：
- 第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；
- 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
- 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
- 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
##### 四次握手：
与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。
- 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。
- 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。
- 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。
- 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

![image](https://upload-images.jianshu.io/upload_images/1863311-67b5e7c8e326435a.png?imageMogr2/auto-orient/strip|imageView2/2/w/875/format/webp)

##### TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？
答：建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。  
（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。  
（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。  
（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。  

##### 超时重传机制  
超时重传指，发送数据包在一定的时间周期内没有收到相应的ACK，等待一定的时间，超时之后就认为这个数据包丢失，就会重新发送。
#####  TCP和UDP的区别
1. TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
2. （1）将数据截断为合理长度。（2）超时重传。（3）应答机制。（4）差错检验。（5）失序重新排序。（6）丢弃重复数据。（7）流量控制（流量控制协议是可变大小的滑动窗口协议）。UDP最大努力交付，并不保证每个包都
3. UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信
4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
5. TCP对系统资源要求较多，UDP对系统资源要求较少。
6. TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报
##### TCP对应的协议和UDP对应的协议
TCP对应的协议：  
（1） FTP：定义了文件传输协议，使用21端口。  
（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。  
（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。  
（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。    
（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。  

UDP对应的协议：   
（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。  
（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。  
（3）TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。  

##### TCP滑动窗口协议
该协议用于网络数据传输时的流量控制，以避免拥塞的发生。协议允许发送方在停止并等待确认前发生多个数据分组，由于方式方不必每发一个分组就停下来等待确认，因此该协议可以加速数据传输，提高网络吞吐量。  
IP层封装TCP/UDP层，但IP层并不保证数据发送到对端，所以TCP通过响应的机制来确保正确发送，但是只有这一个机制效率并不高，这就引入了TCP滑动窗口协议。  
滑动窗口协议通过设置包ID，这样发送端就可以多发送几个数据包，而不需要等待ACK包返回确认


##### 拥塞控制和流量控制的区别
流量控制是，端到端的控制，一端发送数据太快，另一端来不及接收，一般通过滑动窗口的大小的改变实现。  
拥塞控制，是一端到另外一段之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器、以及降低网络性能的所有因素。   

##### TCP拥塞控制
- 发送端控制拥塞窗口原则，没有拥塞时尽量扩大窗口，多传送些包，当堵塞时缩小窗口，减少注入到网络中的分组
- 慢启动，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;
- 拥塞避免，，算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。  
拥塞出现时，拥塞窗口不能无限制的增加，只要出现阻塞就要将慢启动门限设置为发送窗口的一半，然后将拥塞窗口重新设置为1，执行慢启动算法。 
- 快重传（累积确认，接收方计算机知道丢包后，发送三个重复的确认，直接让发送方计算机快速发送丢的包），
- 快恢复，快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。


##### http中浏览器一个URL的流程，这个过程中浏览器做了什么，URL（统一资源定位符）包括哪三个部分？
（1）浏览器向DNS服务器查找输入URL对应的IP地址。  
（2）DNS服务器返回网站的IP地址。  
（3）浏览器根据IP地址与目标web服务器在80端口上建立TCP连接  
（4）浏览器获取请求页面的html代码。  
（5）浏览器在显示窗口内渲染HTML。  
（6）窗口关闭时，浏览器终止与服务器的连接。  


---

---

---


### 什么是Socket
它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据  
我的理解就是Socket就是该模式的一个实现：即socket是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。  
Socket()函数返回一个整型的Socket描述符，随后的连接建立、数据传输等操作都是通过该Socket实现的。
### 网络中进程如何通信
既然Socket主要是用来解决网络通信的，那么我们就来理解网络中进程是如何通信的。 
#####  本地进程通信  
a、消息传递（管道、消息队列、FIFO）  
b、同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）  
c、共享内存（匿名的和具名的，eg:channel）
d、远程过程调用(RPC)  
##### 网络中进程如何通信  
　　ａ、TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机  
　　ｂ、传输层的“协议+端口”可以唯一标识主机中的应用程序（进程），因此，我们利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互  
### Socket怎么通信
利用ip  协议 端口即可实现网络通信，Socket应运而生，它就是利用三元组解决网络通信的一个中间件工具   

##### 接收缓冲区与发送缓冲区
接收区不会立刻接收到数据，存放到缓冲区，等待recv()读取  
发送区不会立即发送，只是通过send()将数据拷贝进入socket的内核发送缓冲区中，等待TCP发送  

##### 面向连接
a. SOCK_STREAM：表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常见的 http 协议就使用 SOCK_STREAM 传输数据，因为要确保数据的正确性，否则网页不能正常解析。==（TCP）==    

SOCK_STREAM 有以下几个特征：
- 数据在传输过程中不会消失；
- 数据是按照顺序传输的；
- 数据的发送和接收不是同步的（有的教程也称“不存在数据边界”）。
- 数据发送路径相同，会通过自学习保存上下游路由地址，建立一条路径
==在操作系统内核态，有接收缓冲区和发送缓冲区==

##### 无连接
b. SOCK_DGRAM：表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为 SOCK_DGRAM 所做的校验工作少，所以效率比 SOCK_STREAM 高。==（UDP）==

可以将 SOCK_DGRAM 比喻成高速移动的摩托车快递，它有以下特征：
- 强调快速传输而非传输顺序；
- 传输的数据可能丢失也可能损毁；
- 限制每次传输的数据大小；
- 数据的发送和接收是同步的（有的教程也称“存在数据边界”）。
- 没有确定的路径，只需要发到接收端即可，偶尔会出现丢包问题

接收方式是同步的，发送两次数据，就接收两次


### TCP/IP协议
##### 概念  
TCP/IP【TCP（传输控制协议）和IP（网际协议）】提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。


- 广播和多播不能用于 TCP
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制
- TCP并不能保证数据一定会被对方接收到，因为这是不可能的。它不是100%可靠的协议，它所能提供的是数据的可靠传递或故障的可靠通知。


##### TCP的粘包问题以及数据的无边界性：　  

TCP的短连接和长连接
###### 什么时候需要考虑粘包问题
1. 短链接不会出现粘包问题，因为只有一种数据结构
2. 发送数据无结构，入文件传输，只管发送和接收，不用考虑粘包
3. 在流传输中出现，UDP不会出现粘包，因为它有消息边界(参考Windows 网络编程)
4. 如果双方建立连接，需要在一段时间内发送不同的结构数据，就有可能发生粘包，这时候就需要分包处理，怎么分也需要双方组织一个比较好的包结构，所以一般可能会在头加一个数据长度之类的包，以确保接收。  
###### 发送粘包的原因
1. 发送端需要等缓冲区满才发送出去，造成粘包  
2. 接收方不及时接收缓冲区的包，造成多个包接收

###### 解决办法
1. 对于由发送端引起的问题，可以通过编程避免，通过push提前将缓冲区的数据立马发送（关闭优化算法，降低网络发送效率）
2. 对于接收端引起的问题，提高进程优先级，及时接收数据（只能减少粘包次数，不能完全避免）
3. 是由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。（应用程序效率较低）

###### 封包和拆包
==封包拆包可以一定程度上避免粘包问题==  
TCP是一个“流协议”，数据之间没有边界间隔，是连成一片的，所以我们常常需要将数据流拆成一个一个的数据包，在接收端拆包就需要在发送端封包

###### 怎样封包和拆包
封包就是给一段数据加上包头,这样一来数据包就分为包头和包体两部分内容了，包头其实上是个大小固定的结构体，里面包括了包体的长度，以及其他自定义的包体数据

##### TCP数据报结构


![image](https://upload-images.jianshu.io/upload_images/11362584-bf1bffccd9cceaff.jpeg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)  
(1) 序号：Seq（Sequence Number）序号占32位，用来标识从计算机A发送到计算机B的数据包的序号，计算机发送数据时对此进行标记。  
(2) 确认号：Ack（Acknowledge Number）确认号占32位，客户端和服务器端都可以发送，Ack = Seq + 1。
(3) 标志位：每个标志位占用1Bit，共有6个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：

```
（1）URG：紧急指针（urgent pointer）有效。
（2）ACK：确认序号有效。
（3）PSH：接收方应该尽快将这个报文交给应用层。
（4）RST：重置连接。
（5）SYN：建立一个新连接。
（6）FIN：断开一个连接。
```

##### 三次握手
TCP建立连接时要传输三个数据包，俗称三次握手（Three-way Handshaking）。可以形象的比喻为下面的对话：

```
第一次握手([SYN], Seq = x)：
客户端发送一个SYN标记的包，Seq初始序列号x，发送完成后客户端进入SYN_SEND状态。（等待确认）
第二次握手：([SYN,ACK], Seq = y, ACK = x + 1)
服务器返回确认包(ACK)应答，同时还要发送一个SYN包回去。ACK = x + 1  Seq = y，发送完成后服务端进入SYN_RCVD状态。 （等待确认）
第二次握手：([ACK], ACK = y + 1)
客户端再次发送确认包(ACK),ACK = y + 1, 表示确认收到服务器的包
```
##### 四次握手
TCP释放连接
```
第一次挥手：
客户端发送一个FIN标记的包，告诉服务器需要关闭连接，表示自己不用发送数据了，
但是还可以接收数据。客户端进入FIN_WAIT_1状态。（停止发送）
第二次挥手：
服务端发送一个ACK的确认包，告诉客户端接收到关闭的请求，但是还没有接收完数据。
发送完成后，服务端进入CLOSE_WAIT状态，客户端收到这个包后，进入FIN_WAIT_2，等待服务器关闭连接。（告诉客户端为接收完数据，还不能断开）
第三次挥手：
服务端准备好关闭连接时，发送FIN标记的包，告诉客户端准备关闭了。
发送完成后，服务端进入LAST_ACK状态，等待客户端确认。（可以断开）
第四次挥手：
客户端接收到服务端的关闭请求，再发送ACK标记的确认包，进入TIME_WAIT状态，等待服务端可能请求重传的ACK包。（如果没有收到ACK包，会发送请求，重新发送）
服务端接收到ACK包后，关闭连接，进入CLOSED状态。
客户端在等待固定时间(两个最大段生命周期 2MSL)后，没有接收到服务的ACK包，认为服务器已关闭连接，自己也关闭连接，进入CLOSED状态。
```

##### 优雅的断开连接–shutdown()
close()/closesocket()和shutdown()的区别：  
close() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，缓冲区的数据也被清除，不回发送  
shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，会等输出缓冲区中的数据传输完毕再发送FIN包。

### OSI模型
![image](https://upload-images.jianshu.io/upload_images/11362584-d6275ac25abac5cc.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/395/format/webp)  
TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中  
　　应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等  
　　传输层：TCP，UDP  
　　网络层：IP，ICMP，OSPF，EIGRP，IGMP  
　　数据链路层：SLIP，CSLIP，PPP，MTU  
　　每一抽象层建立在低一层提供的服务上，并且为高一层提供服务，看起来大概是这样子的  
![image](https://upload-images.jianshu.io/upload_images/11362584-2d26013c75ee45e1.png?imageMogr2/auto-orient/strip|imageView2/2/w/540/format/webp)
![image](https://upload-images.jianshu.io/upload_images/11362584-157a39882f263361.png?imageMogr2/auto-orient/strip|imageView2/2/w/612/format/webp)  
==socket是一个接口，用户程序通过接口实现调用，可以理解为一个外观设计模式，使得用户调用不再繁琐，将网络功能和用户程序区分开来==
### Socket常用函数接口及其原理  
![image](https://upload-images.jianshu.io/upload_images/11362584-31d594363f8cafa0.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp)
![image](https://upload-images.jianshu.io/upload_images/11362584-ec76f69e2ea76d41.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/478/format/webp)  
##### socket缓冲区以及阻塞模式  
socket缓冲区
每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。  

write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。  

TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。

read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取  


```
（1）I/O缓冲区在每个TCP套接字中单独存在；
（2）I/O缓冲区在创建套接字时自动生成；
（3）即使关闭套接字也会继续传送输出缓冲区中遗留的数据；
（4）关闭套接字将丢失输入缓冲区中的数据。
```
输入输出缓冲区的默认大小一般都是 8K，可以通过 getsockopt() 函数获取：  

```
unsigned optVal;
int optLen = sizeof(int);
getsockopt(servSock, SOL_SOCKET, SO_SNDBUF, (char*)&optVal, &optLen);
printf("Buffer length: %d\n", optVal);
```
阻塞模式
对于TCP套接字（默认情况下），当使用 write()/send() 发送数据时：

```
1) 首先会检查缓冲区，如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send()  
会被阻塞（暂停执行），直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据。
2) 如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，
不允许写入，write()/send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。
3) 如果要写入的数据大于缓冲区的最大长度，那么将分批写入。
4) 直到所有数据被写入缓冲区 write()/send() 才能返回。
```
当使用 read()/recv() 读取数据时：

```
1) 首先会检查缓冲区，如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来。
2) 如果要读取的数据长度小于缓冲区中的数据长度，那么就不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压，直到有 read()/recv() 函数再次读取。
3) 直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。
这就是TCP套接字的阻塞模式。所谓阻塞，就是上一步动作没有完成，下一步动作将暂停，直到上一步动作完成后才能继续，以保持同步性。
```
==TCP套接字默认情况下是阻塞模式==  


### 网络游戏编程
https://www.cnblogs.com/xueweihan/p/5452873.htmlUDP vs. TCP  
TCP/IP  
TCP代表“传输控制协议”，IP代表：“互联网协议”，你在互联网上做任何事情，都是建立在这两者的基础上，比如：浏览网页、收发邮件

#### TCP内部的工作原理
TCP是一个数据流的协议，所以你只需要把输入的内容变成数据流，然后TCP协议就会确保数据会到达发送的目的地。TCP是建立在“IP”协议之上，所以TCP必须把用户输入的数据流分成数据包的形式。TCP协议会对需要发送的数据进行排队，然后当有足够的排除数据的时候，就发送数据包到目标计算机。    
网络游戏讲究时效性，而TCP的发送缓冲区和接收缓冲区会造成一定的延迟，这块可以结合粘包问题考虑，为了避免粘包和延迟，可以将TCP socket设置为TCP_NODELAY.这个选项使得TCP socket不需要等待缓冲区满才发送，而是输入数据后就立即发送。  
**TCP_NODELAY**的作用是禁止启用Nagle算法，Nagle算法通过减少需要发送的包，来优化网络  
应对时延敏感的数据时，可以关闭Nagle算法牺牲一定的网络情况来换取输入的快速反映，比如游戏中的键盘信息输入
导致这些问题的原因是因为TCP为了处理丢包和乱序包，而设计了许多安全传输机制，使得我们产生了有序和可靠的错觉。  
当有出错的包将缓冲区堵塞了后，新到达的数据无法读取，等能够读取时，因为网络游戏的时效性，我们已经不需要这个包了，所以再时效性特别强的FPS游戏下，我们尽量应该避免直接使用TCP    

而我们通常说的TCP/UDP混合使用也通常说不建议的，因为TCP的拥塞窗口可能会影响到UDP的丢包率  
在一个程序中tcp的flow control算法可能对udp丢包率造成的影响，而udp的发包率和包大小也会影响tcp的流量控制，并且也会影响网络的吞吐量。  
论文中提到了一个词汇就是TCP Synchronization，大概意思就是不同的tcp连接在同一时间内（或相近）调整window size的行为，这种行为会导致udp丢包率的提高。因为若tcp检测到低丢包率，那么就会增加window size，这样若多个连接同时增加window size，那么同一时刻就会有大量包的发出，从而造成网络的堵塞。若这些连接进而同时检测到packet loss的提高，那么又会同时减少window size，此时网络利用率又下降。而这种同时增大window size的行为，会增大udp的丢包率，详细数据可以参考下面的连接。
http://www.isoc.org/INET97/proceedings/F3/F3_1.HTM

#### 再UDP上建立虚拟连接
UDP是无连接的，一个UDPsocket可以被用作与任意数量的计算机交换书记包，但是再多人游戏中我们只希望一小部分建立连接交换数据，就需要让两天计算机建立虚拟连接

UDP是无连接的，UDPsocket会接收任意计算机发来的包，我们就需要进行过滤，我们并不能通过地址进行过滤，因为UDP并不会像TCP那样去记录地址，所以我们通过再包头里面加入protocol id进行标识，让我们的客户端只接收服务器传过来的包,你只需要选择唯一的数字，可以用hash你的游戏名字和协议版本数字,我们需要确保ID的唯一性

**检测连接**  
多种建立连接的方式  
UDP握手  
请求连接数据包  
检查数据包protocol id建立连接  
通过记录服务器ip地址和端口，客户端可以过滤掉非连接的数据包

**断开连接**


#### lockstep
http://www.skywind.me/blog/archives/112锁定步进算法  
https://zhuanlan.zhihu.com/p/104932624

##### 状态同步
状态同步顾名思义就是同步各个客户端的状态，可能过程不一定同步，但是能保证每一次操作后的状态是一致的。通过开发服务端程序，把用户的操作作为输入实时上传到服务端，服务端通过计算返回结果给各个客户端，这样的过程就是状态同步。
状态同步有几个特点：
- 状态同步的战斗逻辑在服务端
- 在状态同步下，客户端更像是一个服务端数据的表现层
- 一般的流程是客户端上传操作到服务器，服务器收到后计算游戏行为的结果，然后以广播的方式下发游戏中各种状态，客户端收到状态后再根据状态显示内容。

对于逻辑不需要精确到帧的游戏类型而言，允许每个客户端屏幕上显示的内容不同，只要将他们统一到一个逻辑中即可。

其实状态同步是一种乐观的同步方法，认为大家屏幕上的东西不同没关系，只要每次操作的结果相同即可，不需要象“帧间同步”那样保证每帧都一样，因此，对网速的要求也没有 “帧间同步”系列算法那么苛刻。

总结：总得来说，你希望游戏体验更爽快，即时感更强，那么你每秒发包数就越多，每局（副本）支持的人数越少；而你如果追求对网络的容忍，想降低发包数，并且增加同时游戏的人数，那么相应的就需要以降低即时感为代价，其二者不可得兼。
##### 帧同步（lockstep）
LockStep的翻译是锁步同步，是齐步行军的意思。  
是指服务器按帧转发客户端的操作，客户端进行确定性运算和一致性模拟（同步操作两边客户端通过完全一致的操作计算出完全一致的状态）。每帧同步状态这里也认为是状态同步。  

###### P2P 模型 (DOOM)
DOOM (1994) 的网络模型是基于P2P的帧同步。有着帧同步的各种问题，后面会介绍。并且因为没有主机，每个玩家直连其他所有玩家任何一个人卡所有人都卡，是一个非常古老的同步技术。

###### Packet Server (包的简单中继)
这个模型在原版 DOOM 的基础上增加了一个 Packet Server，负责转发所有的 tick command。玩家不再直连其他所有玩家，而是连到这个服务器 (某个玩家机器上) 以获取最新的状态。这样改进后，同步量降低了，一个玩家卡只会自己卡，当然如果服务器卡就会卡。体感可以参考魔兽争霸，主机卡了所有人都会卡。同时如果主机是服务器可以避免绝大部分作弊情况，但如果主机是玩家主机作弊就没办法了。帧同步的其他缺陷也没有得到解决。

###### Client Server (Quake I/II/III)CS架构 
Quake I/II/III 实现了比较典型的 C/S 架构 (1996)。这个模型中服务器负责所有的逻辑判断，客户端本质上只是一个渲染终端。玩家把自己的操作和输入发送给服务器，收到一个实体列表用于渲染。服务器把压缩后的快照按照固定频率发送客户端 客户端使用这些快照来插值或推导出平滑连贯的体验 。  
  
这时候同步机制已经变成了服务器同步操作客户端计算逻辑，服务器同步状态的状态同步了，解决了帧同步的大部分问题。但Quake I还做的比较简单，和帧同步不同的是把所有逻辑相关的放在了服务器，客户端在发送操作之后就要等服务器同步状态。延迟问题还是没有得到解决，同时因为要同步所有状态信息带宽占用很高，当游戏越复杂带宽就越高。  
 
Quake III做了进一步的优化。客户端不是等待服务器而是会预测可能的游戏状态，预测状态和服务器端逻辑使用一套代码，如果服务器和客户端确实不一致，则服务器为准强同步,进行追帧。   

预测也是降低延迟感的一个重要方式，对延迟要求很高的FPS特别重要。并且状态同步服务器同步所有信息，但同样开发的复杂度也会增高，代码需要区分服务器和客户端，需要逻辑和表现分离，需要处理一些联调的问题（服务器和客户端处理时间不一致，预表现差值问题，强同步问题）。

延迟补偿：延迟补偿机制是因为状态同步下客户端和服务器有一定的不一致性，所以服务器在进行计算的时候会有一定的延时补偿，当玩家向某个目标 (若干毫秒前的状态) 射击时，做实际检测的服务器会采用该目标若干毫秒前的状态来检验是否击中。这么做需要服务器把之前一小段时间的状态持续地保存下来，这样不仅增加了实现复杂度，而且导致了某种程度的不一致性。延时高的玩家反而更容易因为补偿获得更有利的判断，严重影响游戏体验 。这种补偿只能对目标的位置回滚，而所有其他环境状态的改变却已无法倒退，这也会影响实际的体验。  

可以看到当玩家比较少的时候，帧同步只需要同步操作，流量会比较小，极省带宽。但是当玩家多的时候每个玩家的操作都要互相同步，带宽就会指数增长，无法优化，反而状态同步可以通过分区域的方式同步支持更多的玩家。（状态同步在服务器中就计算了位置信息，可以进行区域划分，有策略的进行同步状态信息）  

与Quake III 不同，Doom III 的服务器和客户端使用同一份代码来更新/预测实体的状态，这样不用担心服务器和客户端逻辑的互相干扰，同时客户端和服务器也一相同的逻辑帧率运行60fps，每帧客户端上传玩家输入，服务器按固定间隔同步PVS范围内的状态快照，也可以理解为按帧同步的状态同步。    

Doom III在网络上使用UDP，自己通过冗余包和滑动窗口保证服务器消息不丢失和有序并且允许客户端上行丢包，在弱网情况下比TCP延迟更低，不需要TimeOut机制。

与状态同步不同的是，帧同步的服务端开发非常简单，只需要进行指令转发工作即可完成。客户端按照一定的帧速率（理解为逻辑帧，而不是客户端的渲染帧）去上传当前的操作指令，服务端将操作指令广播给所有客户端，当客户端收到指令后执行本地代码，如果输入的指令一致，计算的过程一致，那么计算的结果肯定是一致的，这样就能保证所有客户端的同步，这就是帧同步。  
- 帧同步的战斗逻辑在客户端
- 在帧同步下，通信就比较简单了，服务端只转发操作，不做任何逻辑处理。  

需要注意的问题：  
- 游戏的主循环需要是帧速可控的，依次实现速播
- 为了多端同步，需要使用经过处理的浮点数，帧同步因为需要在客户端计算，所以在多端的情况下浮点数计算不一致。
- 客户端会维持一个滑动窗口，把从最后一次被服务器确认的运动状态到现在的全部输入都发送到服务器，通过输入冗余的方式，来使得预测错误最小化
- 帧同步常需要考虑反外挂的问题，常用的方式有;
- 实时验证。例如战斗实时运行战斗逻辑和客户端不断同步验证关键数据的hash，和状态同步类似。但这种方案服务器负载较高，运维成本高昂；
- 离线验证。这是帧同步的优势，战斗结束后服务器收集整场的操作序列，然后加速播放战斗（几十上百倍），最后校验结果，例如刀塔传奇。这个好处是服务器不用实时跑战斗，只需在结束时花几百ms即可验证一场战斗，大幅降低服务器成本。
![image](https://pic1.zhimg.com/80/v2-a31a53f2cb9a8360baadb788e72d1204_720w.jpg)


##### 混合同步模式
正常同步时使用帧同步，当掉线、存档、回滚、或重播、速播的时候，使用状态同步。这是因为在网络情况较好时，帧同步能确保绝对一致，人数较少时带宽较低，服务器开销低，当网络情况不好时，或者发生**掉线**需要**存档**时，**速播**，使用状态同步，这样通过保存一个中间状态，就可以避免帧同步需要从第一帧模拟计算的缺点


##### 状态同步和帧同步区别
- 最大的区别就是战斗核心逻辑写在哪？状态同步的战斗逻辑在服务端，帧同步的战斗逻辑在客户端。
- 状态同步比帧同步流量消耗大，例如一个复杂游戏的英雄属性可能有100多条，每次改变都要同步一次属性，这个消耗是巨大的，而帧同步不需要同步属性；
- 帧同步的回放&观战比状态同步好做得多，因为只需要保存每局所有人的操作就好了，而状态同步的回放&观战，需要有一个回放&观战服务器，当一局战斗打响，战斗服务器在给客户端发送消息的同时，还需要把这些消息发给放&观战服务器，回放&观战服务器做储存，如果有其他客户端请求回放或者观战，则回放&观战服务器把储存起来的消息按时间发给客户端。
- 状态同步的安全性比帧同步高很多，因为状态同步的所有逻辑和数值都是在服务端的，如果想作弊，就必须攻击服务器，而攻击服务器的难度比更改自己客户端数据的难度高得多，而且更容易被追踪，被追踪到了还会有极高的法律风险。而帧同步因为所有数据全部在客户端，所以解析客户端的数据之后，就可以轻松达到自己想要的效果。
- 帧同步缺点
- 由于逻辑在客户端处理，必须保证客户端状态的高度还原。
- 由于逻辑端在客户端处理，断线重连时，需要从第一帧开始演算到当前帧，才能同步到当前帧状态
- 不能使用自带的物理引擎、浮点数、随机数。否则会导致不同终端设备不能同步还原帧。
![image](https://pic1.zhimg.com/v2-683d328fe83718392d947e8401786fd0_r.jpg)   

上图说到了时延补偿的问题：  
https://snatix.com/2018/05/30/018-lag-compensation/index.html  
这是当我们使用客户端预处理时，  
- 玩家看到 自己 处于 现在
- 玩家看到 其他玩家 处于 过去
所以可能出现明明大中了，却没有爆头的情况，所以服务器为了补偿这个时延，会使用敌人几毫秒前，和你处于同一时间上的位置进行结算，这样就可以打中敌人了。

##### 同步问题中的预表现
客户端中的预表现：是由于服务器回包，为了避免时延问题进行预表现，等服务器的验证到达客户端后，如果预测错误则从错误帧开始，修改后，将缓冲区存的用户操作重新跑一遍，追到当前帧，为了追帧，客户端的gameloop中的关键帧速是可以加快的。  
服务器中的预表现：客户端网络并不是一直稳定的，会发生一定的丢包，而服务器并不能停止模拟，所以当服务器迟迟等不到客户端的包时，会一边进行预测，一边通知客户端，让客户端提高发包的数量，客户端会进行时间膨胀，比约定的帧率更快地进行模拟，等网络状况良好后，客户端会减少发包，缩小时间刻度

1. 建立TCP服务器的各个系统调用
2. 说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？  
首先回答第一个，close并不是一次就能直接关闭，调用close只能将套接字的引用计数减1，可能其他进程还在使用这个套接字，所以并不是直接关闭  
同时在TCP协议中，发送关闭请求时，需要对方回复确认请求，否则不能确认，就会造成一个办半关闭的状态，这个时候可以接收，不能发送。  
3. TCP和UDP的区别
4. 网页解析的过程与实现方法、、在浏览器中输入URL后执行的全部过程（如www.baidu.com）
5. 网络层分片的原因与具体实现，，IP分片  
分片解决不同物理网络最大传输单元（MTU）不同的问题，但是在传输过程中不停的分片重组又会导致一些安全问题  
网络中不同媒介的MTU各不相同，就好比一长段的水管，由不同粗细的水管组成(MTU不同)通过这段水管最大水量就要由中间最细的水管决定。  
当数据包从一个网络A进入另一个网络B时，若原网络的数据包大于另一个网络或者接口的MTU长度，则需要进行分片(若设置DF为1，则丢弃，并回送ICMP不可达差错报文)。因而在IP数据包的报头有若干标识域注明分片包的共同标识号、分片的偏移量、是否最后一片及是否允许分片。传输途中的网关利用这些标识域进可能的再行分片，目有主机把收到的分片进行重组以恢重数据。
6. TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）
7. 为什么使用三次握手，两次握手可不可以？
8. TIME_WAIT的意义（为什么要等于2MSL）
9. 超时重传机制（不太高频），快速重传机制
10. TCP怎么保证可靠性（面向字节流，超时重传，应答机制，滑动窗口，拥塞控制，校验等）？
11. 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？
12. 拥塞控制和流量控制的区别
13. TCP拥塞控制，算法名字？（极其重要）
14. 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？
linux socket使用16bit无符号整型表示端口号，最大到65535，不能改变，规定了是16bit二进制数，但是可以复用，即使用同一个端口号来进行通信
15. TCP/IP的分片粘包过程
16. OSI七层模型与TCP/IP五层模型
17. TCP连接拔掉网线后会发生什么
18. 深入浅出 TCP/IP 协议栈
19. 一个ip配置多个域名，靠什么识别？  
依靠Http请求中host字段，服务器根据host_id转发给不同的端口或者主机
20. 服务器攻击（DDos攻击）  
中文翻译（分布式拒绝服务）利用“肉鸡”对目标网站在短时间内发起大量请求，大规模消耗目标网站的主机资源，让他无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。  
发送访问请求，主机会发送你想要的数据，如果一直请求的话就会一直发送，当大量无意义的访问占据了目标主机的资源后，就会无法正常工作  
- ICMP Flood  ICMP（Internet控制报文协议）用于在IP主机、路由器之间传递控制消息，控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息，虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。    
- UDP Flood量伪造源IP地址的小UDP包冲击DNS服务器或Radius认证服务器
- SYN Flood 利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。
21. OSI七层模型与TCP/IP五层模型  
![image](https://images2018.cnblogs.com/blog/1169376/201807/1169376-20180710111640278-854664480.png)
22. TCP连接拔掉网线后会发生什么




