[TOC]
https://www.cnblogs.com/timlly/p/10463467.html  移动游戏性能优化通用技法
#### 图集处理
影响drawcall数量的根本是batch（批处理数），而batch是一个一个图集来进行批处理的。简单来说，两张image重叠在一起，当两张image的sprite是一个图集里的时候，这两张image就是一个batch；当不是一个图集的时候，两张image就变成了两个batch。所以在处理图集的时候，通常做法是，常用图片放在一个共有图集，然后独立界面的图片放在一个图集，一个UI最好控制在2-3个图集。
- 设计UI时要考虑重用性，如一些边框、按钮等，这些作为共享资源，放在1~3张大图集中，称为重用图集；
- 其它非重用UI按照功能模块进行划分，每个模块使用1~2张图集，为功能图集；

#### 渲染顺序
当图片或者文字出现重叠时，可能会导致drawcall的多余。比如：image->image->text，这样的话，drawcall就是两个，但是当：image->text->image的时候，就算两张image的sprite是一个图集的，这样的drawcall都会有3个。  
同一图集的Image元素应尽量保证在Hierarchy中连续，避免中间插入其他图集的不同组件。避免被其他图集的元素打断drawcall合并。（不同图集下的UI层叠也会打断合批）

#### UI层级的深度
在不必要的情况下，我们尽量减少UI层级的深度。原因是unity自身会提供一个drawcall合并算法。**所有相邻层的可Batch的UI元素将会在一个Drawcall完成。**    
第一步计算UI元素的层级号；  
第二部合并相同层级号中可以Batch的元素作为一个批次，并对批次进行排序。  
这也就解释了，我们为什么要注意Hierarchy窗口中的元素顺序，两个同一深度的元素中间不要插入一个不同深度的资源，不同层级的UI越多，drawcall就会越大。

#### 动静分离
对于经常需要变动更新的UI放到同一个节点下，对于不太经常更新的UI放到一个节点下，由此可以减少了drawcall的次数

#### 静态批处理
静态批处理可以合并网格减少DC次数，但是会增加内存使用量。

#### GPU Instancing
GPU Instancing它可用于非静态对象，与静态批处理相比，它不会激增内存使用量，并且不需要对象是静态的，非常强大。  
我们需要在对象的材质那里设置GPU Instancing，如果你有多个具有相同网格和材质的对象，那么Unity对它们将自动进行批处理，所以网格只上传一份。

GPU实例化让你可以非常高效地绘制相同的网格几次。Unity通过向GPU传递转一个Transform列表来做到这一点。毕竟，每块GameObject都有自己的位置，旋转和缩放。  

但是，创建Transform列表会降低性能。如果在游戏过程中没有物体移动/旋转/缩放，则只需支付一次此开销。但是，如果对象每帧都更改一次，则需要每帧支付一次开销，这一点需要特别注意。所以如果需要在Update修改物体的位置，旋转和缩放就不要使用GPU Instancing。

#### 动态批处理
但是动动态批处理受到更加严格的限制。你只能将其应用于具有少于300个顶点和900个顶点属性（颜色，UV等）的网格。材质也应使用single-pass着色器。

不仅如此，动态批处理非常不可预测。你无法真正确定对象将如何被批处理。结果通常会随着帧的变化而变化。
#### 射线检测
再组件不需要射线检擦时，可以去掉射线检测，在运行的时候，就可以减少不必要的开销

### 背包中如何装10万个物品
不要创建过多子物体，不要多个同时加载，维持一个传送带，只加载生成视线内的物品
1. 获取数据
2. 可视范围 ViewPort的范围  起始位置y 和结束位置y+h
3. 获取那些道具应该被实现 假设格子大小80 * 80，由此计算哪些各自应该被显示，得到启示显示的行数，以及一行有几个，获取起始格子的索引值
4. 记录当前显示的内容
