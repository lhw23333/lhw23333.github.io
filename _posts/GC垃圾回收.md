[TOC]
https://zhuanlan.zhihu.com/p/38799766
#### 垃圾回收机制的作用
- 提高了软件开发的抽象度；
- 程序员可以将精力集中在实际的问题上而不用分心来管理内存的问题；
- 可以使模块的接口更加的清晰，减小模块间的偶合；
- 大大减少了内存人为管理不当所带来的Bug；
- 使内存管理更加高效。

#### 什么是GC
Garbage Collector，以应用程序的root为基础，遍历应用程序在Heap上动态分配的所有对象，通过识别它们是否被引用来确定哪些对象是已经死亡的、哪些仍需要被使用。已经不再被应用程序的root或者别的对象所引用的对象就是已经死亡的对象，即所谓的垃圾，需要被回收。  
为了判断对象是否需要回收，需要用到多种算法。

##### 引用计数算法
优点：
1. 可以立即释放引用次数为0的内存
2. 可以与程序运行同时进行，不需要挂起占用主线程
缺点：
1. 无法解决循环引用问题
2. 实现高效的引用技术问题，计数带来的内存浪费，以及频繁修改计数值的操作
3. 减少一个对象的引用计数时，会级联减少其引用对象的计数，可能造成多次释放的问题	

##### Mark-Compact 标记压缩算法
缺点：
1. mark过程会挂起
2. 容易造成碎片
3. 内存上不同年龄的内存呆在一起

可以将.NET使用的GC算法看作Mark—Compact算法。  
该算法可以简单分为2个不步骤，
- ①Mark-Sweep(标记清楚阶段) 先假设heap中所有对象都可以回收，然后找出不能回收的对象，给这些对象打上标记，最后heap中没有打标记的对象都是可以被回收的；  
![image](https://pic1.zhimg.com/v2-afa4f38d325a8cd321d09c8d2d249b70_r.jpg)
- ②Compact(压缩阶段)，对象回收之后heap内存空间变得不连续，在heap中移动这些对象，使他们重新从heap基地址开始连续排列，类似于磁盘空间的碎片整理。  
Heap内存经过回收、压缩之后，可以继续采用前面的heap内存分配方法，即仅用一个指针记录heap分配的起始地址就可以。主要处理步骤：将线程挂起→确定roots→创建reachable objects graph→对象回收→heap压缩→指针修复。可以这样理解roots：heap中对象的引用关系错综复杂（交叉引用、循环引用），形成复杂的graph，roots是CLR在heap之外可以找到的各种入口点。  
GC搜索roots的地方包括全局对象、静态变量、局部对象、函数调用参数、当前CPU寄存器中的对象指针，修复指针指的是对heap中对象进行压缩后，地址发生改变，需要修改所有指针的指向。
![image](https://pic1.zhimg.com/80/v2-e4af96723d84543be28abc3fa0787a94_720w.jpg)

GC Root  
虚拟机栈（栈帧中的本地变量表）中引用的对象

本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

方法区中类静态属性引用的对象

方法区中常量引用的对象

##### Generational 分代算法
程序可能使用几百M、几G的内存，对这样的内存区域进行GC操作成本很高，分代算法具备一定统计学基础，对GC的性能改善效果比较明显。将对象按照生命周期分成新的、老的，根据统计分布规律所反映的结果，可以对新、老区域采用不同的回收策略和算法，加强对新区域的回收处理力度，争取在较短时间间隔、较小的内存区域内，以较低成本将执行路径上大量新近抛弃不再使用的局部对象及时回收掉。  

分代算法的假设前提：
1. 大量新创建的对象生命周期都比较短，而较老的对象生命周期会更长；（一段代码中后创建的对象生命周期短，先创建的生命周期长）。
2. 对部分内存进行回收比基于全部内存的回收操作要快；
3. 新创建的对象之间关联程度较强。heap分配的对象是连续的，关联程度较强有利于提高CPU的cache命中率，.NET将heap分成三个代领区域：Gen 0，Gen 1， Gen 2  
![image](https://pic2.zhimg.com/80/v2-8b089380d3908280fd621838a8d5e8d5_720w.jpg)
将Heap分为三个区域，对于不同区域有三种GC方式。如果Gen 0 heap内存达到阈值，则触发0代GC，0代中幸存的对象进入Gen1.如果Gen 1的内存达到阈值，则进行1带GC，1代GC将Gen 0 heap和Gen 1 heap一起进行回收，2代，1代，0代GC的频率比大致是1：10：100；

#####  增量式GC
增量式（incremental）GC 顾名思义，允许 collector 分多个小批次执行，每次造成的 mutator 停顿都很小，达到近似实时的效果。

![](https://img.alicdn.com/imgextra/i3/581166664/TB2QgDSJASWBuNjSszdXXbeSpXa_!!581166664.png)

引用计数类 GC 本身就具有增量式特性，但由于其算法自身的缺陷与效率问题，一般不会采用。而追踪类 GC 实现增量式的难点在于：在 collector 遍历引用关系图，mutator 可能会改变对象间的引用关系
这其实是一个并发问题，collector 线程与 mutator 线程同时去读/写一些共享的数据结构（引用关系图），这就要求把它保护起来，使 collecotr 与 mutator 能够感知其改变，并作出相应调整。 在 GC 期间，对 mutator 改变「引用关系图」的保守度（conservatism）是增量式 GC 一大特性。如果 mutator 在 collector 遍历某对象后将其释放（floating garbage），那么这个对象在本次 GC 不会被回收，但在下一轮 GC 开始时会被回收。 这种弱一致性（relaxed consistency）是允许的，因为它不会对程序逻辑造成影响，只是延迟了垃圾对象的回收，而且一致性越弱，遍历算法的实现就可以更灵活。

三色标记（tricolor marking）抽象屏蔽了 GC 实现的算法（MS/Copying）、遍历策略（宽度优先/深度优先）等细节，对于理解增量式 GC 十分有帮助。具体来说是在 GC 遍历引用关系图时，对象会被标为三种颜色：

黑色black，表明对象被 collector 访问过，属于可到达对象
灰色gray，也表明对象被访问过，但是它的子节点还没有被 scan 到
白色white，表明没有被访问到，如果在本轮遍历结束时还是白色，那么就会被收回
对于 MS 来说，设置标记位就是着色的过程：有 mark-bit 的即为黑色。对 Copying GC 来说，把对象从 fromspace 移动到 tospace 就是着色过程：在 fromspace 中不可到达的对象为白色，被移动到 tospace 的对象为黑色。 对于增量时 GC 来说，需要在黑白之间有个中间状态来记录「那些之前被 collector 标记黑色，后来又被 mutator 改变的对象」，这就是灰色的作用。 对于 MS 来说，灰色对象是用于协助遍历 queue 里面的对象，即上文中描述的 worklist 里面的对象。对于 Copying GC 来说，灰色对象就是那些在 topspace 中还没被 scan 的对象，如果采用 Cheney 的宽度优先遍历算法 ，那么就是 scan 与 free 指针之间的对象。

增加的中间状态灰色要求 mutator 不会把黑色对象直接指向白色对象（这称为三色不变性 tri-color invariant），collector 就能够认为黑色对象不需要在 scan，只需要遍历灰色对象即可。
##### Finalization Queue和Freachable Queue
这两个队列并不用于存储真正的对象，而是存储一组指向对象的指针。当程序中使用了new操作符在Managed Heap上分配空间时，GC会对其进行分析，如果该对象含有Finalize方法则在Finalization Queue中添加一个指向该对象的指针。即：对托管对象进行跟踪。 
- finalize是为了在GC回收之前调用的一个方法，目的是为了实现资源清理，如果finalize()没有被调用，是暂时不能回收的
- finalize和析构函数并不对应，析构的调用时机是确定的，而finlize的时机是不确定的，更多的是对析构函数的一个补充，用来释放非内存资源对象（如Socket，文件等）
所以当我们回收的垃圾中如果有finalization队列中的对象，会暂时复生，并将指向它的指针移动到freachable队列中，一旦添加进去，就会触发所指对象的finalize方法，之后将这个指针从队列中删除，该对象就可以正常消失回收掉。

##### 托管资源
.NET的所有类型都是（直接或间接）从System.Object类型派生的。  
CTS中的类型被分成两大类--引用类型，分配在内存堆上；值类型，分配在堆栈上
![image](https://pic4.zhimg.com/80/v2-9a7b366696b895b3164a1eef93b846a3_720w.jpg)
值类型在栈里，先进后出，值类型变量的生命有先后顺序，这个确保了值类型变量在退出作用域以前会释放资源。比引用类型更简单和高效。堆栈是从高地址往低地址分配内存。  
- GC并不是能释放所有的资源，它不能自动释放非托管资源。
- GC并不是实时性的，这将会造成系统性能上的瓶颈和不确定性。  

　GC并不是实时性的，这会造成系统性能上的瓶颈和不确定性。所以有了IDisposable接口，IDisposable接口定义了Dispose方法，这个方法用来供程序员显式调用以释放非托管资源。使用using语句可以简化资源管理。

##### GC.Collect() 方法
作用：强制进行垃圾回收  
GC的方法：
![image](https://pic1.zhimg.com/v2-5bb972041c21d026050d0fabc5605968_r.jpg)

##### GC注意事项
1. 只管理内存，非托管资源，如文件句柄，GDI资源，数据库连接等还需要用户去管理。所以引入finalize方法在GC回收之前去释放非托管资源。
2. 循环引用，网状结构等的实现会变得简单。GC的标志-压缩算法能有效的检测这些关系，并将不再被引用的网状结构整体删除
3. GC通过从程序的根对象开始遍历来检测一个对象是否可被其他对象访问，而不是用类似于COM中的引用计数方法。
4. GC在一个独立的线程中运行来删除不再被引用的内存。
5. GC每次运行时会压缩托管堆。
6. 你必须对非托管资源的释放负责。可以通过在类型中定义Finalizer来保证资源得到释放。
7. 对象的Finalizer被执行的时间是在对象不再被引用后的某个不确定的时间。注意并非和C++中一样在对象超出声明周期时立即执行析构函数
8. Finalizer的使用有性能上的代价。需要Finalization的对象不会立即被清除，而需要先执行Finalizer.Finalizer，不是在GC执行的线程被调用。GC把每一个需要执行Finalizer的对象放到一个队列中去，然后启动另一个线程来执行所有这些Finalizer，而GC线程继续去删除其他待回收的对象。在下一个GC周期，这些执行完Finalizer的对象的内存才会被回收。
9. .NET GC使用"代"(generations)的概念来优化性能。代帮助GC更迅速的识别那些最可能成为垃圾的对象。在上次执行完垃圾回收后新创建的对象为第0代对象。经历了一次GC周期的对象为第1代对象。经历了两次或更多的GC周期的对象为第2代对象。代的作用是为了区分局部变量和需要在应用程序生存周期中一直存活的对象。大部分第0代对象是局部变量。成员变量和全局变量很快变成第1代对象并最终成为第2代对象。
10. GC对不同代的对象执行不同的检查策略以优化性能。每个GC周期都会检查第0代对象。大约1/10的GC周期检查第0代和第1代对象。大约1/100的GC周期检查所有的对象。重新思考Finalization的代价：需要Finalization的对象可能比不需要Finalization在内存中停留额外9个GC周期。如果此时它还没有被Finalize，就变成第2代对象，从而在内存中停留更长时间。

##### 如何判断为垃圾可回收

###### 引用计数算法
给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值就加1;当引用失效时,计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。

引用计数为0时，进行垃圾回收，引用计数算法将垃圾收集的开销分摊到整个程序的运行中，而其他间接的垃圾回收时需要挂起整个应用的运行，知道所有对象都处理结束。

引用计数何时修改引用数：  
强指针 sp 重载了 "=" 运算符，在引用其他对象时将强引用计数 +1，在 sp 析构函数中将强引用计数 -1，当强引用计数减至 0 时销毁引用的对象，这样就实现了对象的自动释放。

弱指针引用其他对象时将弱引用计数 +1，在 wp 析构函数中将弱引用计数 -1，当强引用计数为 0 时，不论弱引用计数是否为 0 都销毁引用的对象。

- 强引用 创建时引用计数＋1，销毁时-1，使用new创建的引用关系就是强引用
- 弱引用 智能指针中的weak_ptr，需要通过shared_ptr来创建，进行该对象内存管理的是强引用的那个shared指针，weak指针只是提供了对管理对象的一个访问手段

##### 循环引用
当对象A和对象B,相互引用了对方作为自己的成员变量,只有自己销毁的时,才能将成员变量的引用计数减1,因为对象A的销毁依赖于对象B的销毁, 对象B的销毁依赖于对象A的销毁,这样子就造成了循环引用,即使外部没有指针能够访问他们,但是他们依然不能被释放.
- 引用计数并不能很好的解决循环引用的问题
- 解决方法1，断开其中一个引用
- 解决方法2，若 A 强引用了 B，那 B 引用 A 时就需使用弱引用，当判断是否为无用对象时仅考虑强引用计数是否为 0，不关心弱引用计数的数量

###### GC Roots（可达性分析）
就是通过一系列的称为“GC Roots”的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连(用图论的话来说,就是从GC Roots到这个对象不可达)时,则证明此对象是不可用的。

可当作GC Roots的对象
- 虚拟机栈(栈帧中的本地变量表)中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI(即一般说的Native方法)引用的对象。


##### 垃圾回收触发条件
被动触发
- 1. 当垃圾存储到一定时候，会被动触发回收这些无用内存。
- 2. 堆分配时堆上的可用内存不足时触发GC。

主动触发
- Mono GC主动调用的接口是Resources.UnloadUnusedAssets()。
- C# GC也提供了同样的接口GC.Collect()
- LuaGC主动调用collectgarbage("collect"):做一次完整的垃圾收集循环。
- 有一点需要说明的是，Resources.UnloadUnusedAssets()内部本身就会调用GC.Collect()。
- Unity还提供了另外一个更加暴力的方式——Resources.UnloadAssets()来卸载资源，但是这个接口无论资源是不是“垃圾”，都会直接删除，是一个很危险的接口，建议确定资源不使用的情况下，再调用该接口。

##### 如何提高GC效率来提高游戏的性能？

在执行GC时会占用主线程，所以我们要尽量避免频繁GC或者控制GC的出发时机。

- 如果垃圾内过多，被动触发次数过多，会造成CPU负荷过多，GC是由CPU启动的。
- 如果堆上有很多对象和大量的对象引用要检查，则检查所有这些对象的过程可能很慢。这可能导致游戏卡顿或缓慢运行。
- GC在不合时宜的场合被触发。如果CPU在我们游戏的性能关键部分已经满负荷了，那此时即使是少量的GC额外开销也可能导致我们的游戏卡顿或运行缓慢。

优化GC（减少GC的次数）  
- 尝试在合适时机（loading时），手动触发GC和扩展堆大小以便GC可控。
- 如果在代码中反复调用某些造成堆内存分配的函数但是其返回结果并没有使用，这就会造成不必要的内存垃圾，我们可以缓存这些变量来重复利用，这就是缓存。函数里的局部变量，设置为公共成员变量。
- 避免重复调用的函数中分配内存（update）
- 对象池。
- 清理容器。
- 字符串的创建之类。tostring等方法
- 匿名函数会被应用托管，产生垃圾
- 注意装箱，装箱的回收会产生垃圾
- StartCortine会产生少量垃圾。

```
yield return num；
//不管num为多少，都是下一帧执行，但是为了避免内存垃圾，可以return null
WaitForSeconds delay = new WaiForSeconds(1f);
while(!isComplete) {
    yield return delay;
}
//避免每次yield都创建新对象
```

拓展：
